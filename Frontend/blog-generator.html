<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BlogMagic - Generate Your Blog</title>
    <link rel="stylesheet" href="styles.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Toastify CSS -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <!-- jsPDF library for PDF generation -->
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js" onload="console.log('jsPDF loaded successfully from unpkg')" onerror="console.error('Failed to load jsPDF from unpkg, trying cdnjs...')"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" onload="console.log('jsPDF loaded successfully from cdnjs')" onerror="console.error('Failed to load jsPDF from both CDNs')"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" onload="console.log('html2canvas loaded successfully')" onerror="console.error('Failed to load html2canvas from CDN')"></script>
    <script>
        // Enhanced jsPDF initialization with multiple fallbacks
        let jsPDFCheckInterval;
        let attempts = 0;
        const maxAttempts = 10;
        
        function checkAndInitjsPDF() {
            attempts++;
            console.log(`Checking jsPDF availability (attempt ${attempts}/${maxAttempts})`);
            
            if (typeof jsPDF !== 'undefined') {
                window.jsPDF = jsPDF;
                console.log('‚úÖ jsPDF initialized successfully (global)');
                clearInterval(jsPDFCheckInterval);
                return true;
            } else if (typeof window.jsPDF !== 'undefined') {
                console.log('‚úÖ jsPDF already available (window)');
                clearInterval(jsPDFCheckInterval);
                return true;
            } else if (typeof window.jspdf !== 'undefined' && window.jspdf.jsPDF) {
                window.jsPDF = window.jspdf.jsPDF;
                console.log('‚úÖ jsPDF initialized from window.jspdf');
                clearInterval(jsPDFCheckInterval);
                return true;
            } 
            
            if (attempts >= maxAttempts) {
                console.error('‚ùå jsPDF not found after multiple attempts, loading fallback...');
                clearInterval(jsPDFCheckInterval);
                
                // Load from alternative CDN
                const script = document.createElement('script');
                script.src = 'https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js';
                script.onload = () => {
                    setTimeout(() => {
                    if (typeof jsPDF !== 'undefined') {
                            window.jsPDF = jsPDF;
                            console.log('‚úÖ jsPDF loaded from fallback CDN');
                        } else {
                            console.error('‚ùå Failed to load jsPDF from fallback CDN');
                    }
                    }, 100);
                };
                script.onerror = () => {
                    console.error('‚ùå Failed to load jsPDF from fallback CDN');
                };
                document.head.appendChild(script);
                return false;
            }
            
            return false;
        }
        
        // Start checking immediately and every 200ms
        window.addEventListener('DOMContentLoaded', function() {
            checkAndInitjsPDF();
            jsPDFCheckInterval = setInterval(checkAndInitjsPDF, 200);
        });
        
        // Also check when page loads
        window.addEventListener('load', function() {
            if (!checkAndInitjsPDF()) {
                // One more attempt after full page load
                setTimeout(checkAndInitjsPDF, 1000);
            }
        });
    
        // Global function to make element draggable - accessible throughout the application
        function makeDraggable(element) {
            if (!element) {
                console.warn('makeDraggable: No element provided');
                return;
            }
            
            console.log('‚úÖ makeDraggable: Initializing draggable functionality for element:', element);
            
            let pos1 = 0,
                pos2 = 0,
                pos3 = 0,
                pos4 = 0;
                
            // Make the modal header the drag handle
            const dragHandle = element.querySelector(".modal-header");
            if (dragHandle) {
                dragHandle.style.cursor = "move";
                dragHandle.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                // Don't start drag if clicking the close button
                if (e.target.closest(".close-modal-btn")) {
                    return;
                }
                
                e.preventDefault();
                
                // Ensure element has proper positioning before dragging
                if (element.style.position !== "fixed") {
                    element.style.position = "fixed";
                }
                
                // Get the mouse cursor position at startup
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // Call a function whenever the cursor moves
                document.onmousemove = elementDrag;

                // Remove the transform when starting to drag and add dragging class
                element.style.transform = "none";
                element.classList.add("dragging");
                
                // Change cursor for entire document while dragging
                document.body.style.cursor = "move";
            }

            function elementDrag(e) {
                e.preventDefault();
                // Calculate the new cursor position
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // Calculate new position
                let newTop = element.offsetTop - pos2;
                let newLeft = element.offsetLeft - pos1;
                
                // Prevent dragging off-screen (keep at least 50px visible)
                const minVisible = 50;
                const maxTop = window.innerHeight - minVisible;
                const maxLeft = window.innerWidth - minVisible;
                
                newTop = Math.max(-element.offsetHeight + minVisible, Math.min(newTop, maxTop));
                newLeft = Math.max(-element.offsetWidth + minVisible, Math.min(newLeft, maxLeft));
                
                // Set the element's new position
                element.style.top = newTop + "px";
                element.style.left = newLeft + "px";
            }

            function closeDragElement() {
                // Stop moving when mouse button is released
                document.onmouseup = null;
                document.onmousemove = null;
                
                // Remove dragging class and restore cursor
                element.classList.remove("dragging");
                document.body.style.cursor = "default";
            }
        }
        
        // Verify the function is globally accessible
        console.log('‚úÖ makeDraggable function defined globally:', typeof makeDraggable === 'function');
    </script>
    <!-- Add Quill dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/quill@2.0.3/dist/quill.snow.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/gh/hunghg255/quill-resize-module@latest/dist/quill-resize-image.min.js"></script>
    <!-- Add Lottie animation library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <!-- Toastify JS -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
    <style>
        /* New Blog Button and History Button Styles */
        .new-blog-button,
        .history-button {
            background: linear-gradient(135deg, #00b894, #00a085);
            color: white;
            border: none;
            border-radius: 25px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 184, 148, 0.2);
            height: 40px;
            margin: 0;
        }

        .new-blog-button {
            background: linear-gradient(135deg, #6c5ce7, #5f4dd0);
            box-shadow: 0 2px 8px rgba(108, 92, 231, 0.2);
            border-radius: 50% !important;
            width: 40px;
            height: 40px;
            padding: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            min-width: 40px;
            gap: 0 !important;
        }

        .new-blog-button:hover {
            background: linear-gradient(135deg, #5f4dd0, #4a3dbf);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
        }

        .new-blog-button i {
            font-size: 18px !important;
            margin: 0 !important;
            padding: 0 !important;
            line-height: 1 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }

        .history-button:hover {
            background: linear-gradient(135deg, #00a085, #009178);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 184, 148, 0.3);
        }

        .new-blog-button:active,
        .history-button:active {
            transform: translateY(0);
        }

        .new-blog-button i,
        .history-button i {
            font-size: 16px;
        }

        .chat-header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 0;
        }

        .header-buttons {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-header-content .image-logo {
            height: 40px;
            width: auto;
        }

        @media (max-width: 560px) {
            .history-button {
                padding: 6px 12px;
                font-size: 12px;
                height: 36px;
            }

            .new-blog-button {
                width: 36px;
                height: 36px;
                padding: 0 !important;
                gap: 0 !important;
            }

            .header-buttons {
                gap: 6px;
            }

            .new-blog-button i {
                font-size: 16px !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            .history-button i {
                font-size: 14px;
            }

            .history-button span {
                display: none;
            }

            .chat-header-content .image-logo {
                height: 32px;
            }
        }

        @media (max-width: 320px) {
            .history-button {
                padding: 4px 8px;
                font-size: 10px;
                border-radius: 20px;
                height: 32px;
            }

            .new-blog-button {
                width: 32px;
                height: 32px;
                padding: 0 !important;
                gap: 0 !important;
            }

            .header-buttons {
                gap: 4px;
            }

            .new-blog-button i {
                font-size: 14px !important;
                margin: 0 !important;
                padding: 0 !important;
            }

            .history-button i {
                font-size: 12px;
            }
        }

        /* Restore Button Styles */
        .restore-button {
            background: linear-gradient(135deg, #ff7675, #e17055);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin-left: 8px;
            opacity: 0.8;
            font-size: 10px;
            box-shadow: 0 2px 4px rgba(255, 118, 117, 0.2);
            position: absolute;
            top: 8px;
            right: 8px;
        }

        .restore-button:hover {
            background: linear-gradient(135deg, #e17055, #d63031);
            transform: scale(1.1);
            opacity: 1;
            box-shadow: 0 4px 8px rgba(255, 118, 117, 0.3);
        }

        .restore-button:active {
            transform: scale(0.95);
        }

        .restore-button i {
            font-size: 10px;
            line-height: 1;
        }

        /* Ensure message-meta has relative positioning for absolute restore button */
        .message-meta {
            position: relative;
        }

        /* Hide restore button on very small screens */
        @media (max-width: 480px) {
            .restore-button {
                width: 20px;
                height: 20px;
                font-size: 8px;
                top: 4px;
                right: 4px;
            }

            .restore-button i {
                font-size: 8px;
            }
        }

        /* Add to Chat Button Styles */
        .add-to-chat-button {
            position: absolute;
            background: linear-gradient(135deg, #6c5ce7, #5f4dd0);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 6px 12px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(108, 92, 231, 0.3);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 4px;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
        }

        .add-to-chat-button.show {
            opacity: 1;
            transform: translateY(0);
            pointer-events: all;
        }

        .add-to-chat-button:hover {
            background: linear-gradient(135deg, #5f4dd0, #4a3dbf);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.4);
        }

        .add-to-chat-button:active {
            transform: translateY(0);
        }

        .add-to-chat-button i {
            font-size: 10px;
        }

        /* Ensure Quill editor has relative positioning for absolute button */
        .ql-editor {
            position: relative;
        }
    </style>
</head>
<body>
    <!-- Authentication Check -->
    <script>
        // Handle page unload events
      window.addEventListener("beforeunload", function (e) {
            // Always save chat history before leaving
            saveChatHistory();
        });
        
        // Handle page visibility change (for better refresh detection)
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                // Page is being hidden (user is leaving or refreshing)
                saveChatHistory();
            }
        });

        // Check if user is logged in via token or cookie
      const token = localStorage.getItem("token");
      const userCookie = document.cookie
        .split(";")
        .find((cookie) => cookie.trim().startsWith("user="));
        
        // Debug authentication status
        console.log('üîê Authentication Check:');
        console.log('Token exists:', !!token);
        console.log('User cookie exists:', !!userCookie);
        console.log('Token preview:', token ? token.substring(0, 20) + '...' : 'No token');
        
        if (!token && !userCookie) {
            console.log('‚ùå No authentication found, redirecting to login');
        window.location.href = "login.html";
        } else {
            console.log('‚úÖ Authentication found, proceeding');
        }
    </script>

    <div class="blog-generator">
        <!-- Chat Section -->
        <div class="chat-section" id="chat-section">
            <div class="chat-header">
                <div class="chat-header-content">
            <img
              class="image-logo"
              src="assets/logo2-removebg-preview.png"
              alt="BlogMagic Logo"
              style="cursor: pointer;"
              onclick="window.location.href='index.html'"
              title="Click to go back to landing page"
            />
                    <div class="header-buttons">
              <button
                class="history-button"
                id="history-button"
                title="View Blog History"
              >
                        <i class="fa-solid fa-clock-rotate-left"></i>
                        <span>History</span>
                    </button>
              <button
                class="new-blog-button"
                id="new-blog-button"
                title="Start New Blog"
              >
                            <i class="fa-solid fa-plus"></i>
                    </button>
                    </div>
                </div>
            </div>
            <button class="mobile-chat-toggle" id="mobile-chat-toggle">
                <i class="fa-solid fa-comments"></i>
            </button>
            <div class="chat-messages" id="chat-messages">
                <!-- Messages will be added here dynamically -->
            </div>
            <div class="chat-input-container">
          <textarea
            id="user-input"
            placeholder="Type your message here..."
            rows="1"
          ></textarea>
                    <button class="send-button">
                        <i class="fa-solid fa-paper-plane"></i>
                    </button>
                </div>
        </div>

        <!-- Output Section -->
        <div class="output-section">
            <div class="output-header">
          <img
            src="assets/logo2-removebg-preview.png"
            alt="BlogMagic Logo"
            class="back-to-chat-btn"
            id="back-to-chat-btn"
          />
                <h2>Your Blog Post</h2>
                <div class="output-actions">
                    <button class="generated-images-button">
                        <i class="fa-solid fa-images"></i>
                        <span>Generated Images</span>
                    </button>
                    <div class="dropdown-container">
                        <button class="action-button" id="generate-image-button">
                            <i class="fa-solid fa-wand-magic-sparkles"></i>
                <span style="font-size: 12px">Generate Image</span>
                        </button>
                        <div class="dropdown-menu" id="headings-dropdown">
                            <div class="dropdown-header">
                                <h3>Select Section</h3>
                                <button class="close-dropdown" title="Close">
                                    <i class="fa-solid fa-xmark"></i>
                                </button>
                            </div>
                            <div class="dropdown-content">
                                <!-- Headings will be added here dynamically -->
                            </div>
                            <div class="dropdown-footer">
                                <button class="generate-all-btn">Generate All Images</button>
                            </div>
                        </div>
                    </div>
                    <button class="action-button" id="copy-button">
                        <i class="fa-solid fa-copy"></i>
                    </button>
                    <button class="action-button" id="download-button">
                        <i class="fa-solid fa-download"></i>
                    </button>

                </div>
            </div>
        <div style="padding: 0" class="blog-output" id="blog-output">
          <div id="keyword-loading-overlay" style="display: none">
                    <div id="keyword-loading-animation"></div>
                    <p>Fetching keywords<span class="loading-dots"></span></p>
            <p>
              It may take 1-2 minutes to fetch the keywords<span
                class="loading-dots"
              ></span>
            </p>
                </div>
          <div id="loading-overlay" style="display: none">
                    <div class="loading-spinner">
                        <i class="fa-solid fa-wand-magic-sparkles"></i>
                    </div>
            <div id="lottie-loader" style="width: 300px; height: 300px"></div>
            <div
              id="lottie-loader-image"
              style="width: 300px; height: 300px"
            ></div>
                    <p>Generating your blog post<span class="loading-dots"></span></p>
            <p>
              It may take 1-2 minutes to generate the blog post<span
                class="loading-dots"
              ></span>
            </p>
                </div>
          <div id="humanize-loading-overlay" style="display: none">
            <div
              id="humanize-loading-animation"
              style="width: 320px; height: 320px; margin: 0 auto"
            ></div>
                    <p>Humanizing your content<span class="loading-dots"></span></p>
            <p>
              Making your content more natural and engaging<span
                class="loading-dots"
              ></span>
            </p>
                </div>
                <div id="editor">
                    <h2>Write a blog here or generate a blog using the chat section</h2>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Update modal HTML -->
    <div class="modal-overlay" id="imageModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Choose an option</h3>
                <button class="close-modal-btn">
                    <i class="fa-solid fa-xmark"></i>
                </button>
            </div>
            <div class="modal-buttons">
          <button class="modal-button primary" id="generateImageBtn">
            Generate Image using AI
          </button>
          <button class="modal-button secondary" id="uploadImageBtn">
            Upload Image
          </button>
          <button class="modal-button danger" id="removeImageBtn">
            Remove Image
          </button>
            </div>
            <div class="prompt-input-container" id="promptInputContainer">
          <input
            type="text"
            class="prompt-input"
            id="promptInput"
            placeholder="Enter your image prompt here..."
          />
                <div class="prompt-actions">
            <button class="modal-button secondary" id="cancelPromptBtn">
              Cancel
            </button>
            <button class="modal-button primary" id="submitPromptBtn">
              Generate
            </button>
                </div>
            </div>
        <input
          type="file"
          id="imageUploadInput"
          accept="image/*"
          style="display: none"
        />
        </div>
    </div>
    <!-- <script src="script.js"></script> -->
     <script>
        // Add this at the top level of your script
        let currentBlogId = null; // Track current blog ID in memory instead of localStorage
        let isFirstPrompt = true; // Track if this is the first prompt in the conversation
        let conversationStarted = false; // Track if conversation has started
        
        // Make conversation state variables globally accessible
        window.isFirstPrompt = isFirstPrompt;
        window.conversationStarted = conversationStarted;
        window.currentBlogId = currentBlogId;

        // Debug: Check what resize modules are available
        console.log("Debug: Available modules:", {
            QuillResizeImage: typeof QuillResizeImage,
            QuillResizeModule: typeof QuillResizeModule,
            window_QuillResizeImage: typeof window.QuillResizeImage
        });

        // Register the resize module
        if (typeof QuillResizeImage !== "undefined") {
            Quill.register("modules/resize", QuillResizeImage);
            console.log("‚úÖ QuillResizeImage module registered successfully");
        } else if (typeof window.QuillResizeImage !== "undefined") {
            Quill.register("modules/resize", window.QuillResizeImage);
            console.log("‚úÖ QuillResizeImage (window) module registered successfully");
        } else {
            console.warn("‚ö†Ô∏è QuillResizeImage module not available");
        }

        // Initialize Quill editor
        const quill = new Quill("#editor", {
        theme: "snow",
            modules: {
                toolbar: [
            [{ header: [1, 2, 3, 4, 5, 6, false] }],
            ["bold", "italic", "underline", "strike"],
            [{ list: "ordered" }, { list: "bullet" }],
            [{ color: [] }, { background: [] }],
            ["link", "image"],
            ["clean"],
                ],
                clipboard: {
                    matchVisual: false,
                    matchers: [
              [
                "img, iframe, video",
                function (node, delta) {
                  const isImage = node.tagName.toLowerCase() === "img";
                            return {
                                ops: [
                      { insert: "\n" }, // Single line before
                                    {
                                        insert: {
                          [node.tagName.toLowerCase() === "img"
                            ? "image"
                            : "video"]: node.src,
                        },
                                    },
                                    // Add extra newline only for images
                      { insert: isImage ? "\n\n" : "\n" },
                    ],
                            };
                },
              ],
            ],
                                },
        },
        });

        // Implement reliable custom image resize functionality
        function setupImageResize() {
            let selectedImage = null;
            let resizeOverlay = null;
            let resizeToolbar = null;
            let isResizing = false;

            // Create resize overlay with handles
            function createResizeOverlay() {
                const overlay = document.createElement('div');
                overlay.className = 'image-resize-overlay';
                overlay.style.cssText = `
                    position: absolute;
                    pointer-events: none;
                    border: 2px solid #6c5ce7;
                    border-radius: 4px;
                    display: none;
                    z-index: 1000;
                `;

                // Create resize handles
                const handles = ['nw', 'ne', 'sw', 'se', 'n', 's', 'w', 'e'];
                handles.forEach(handle => {
                    const handleEl = document.createElement('div');
                    handleEl.className = `resize-handle resize-handle-${handle}`;
                    handleEl.style.cssText = `
                        position: absolute;
                        background: #6c5ce7;
                        border: 2px solid white;
                        border-radius: 50%;
                        width: 12px;
                        height: 12px;
                        pointer-events: auto;
                        cursor: ${getHandleCursor(handle)};
                        z-index: 1001;
                    `;
                    
                    // Position handles
                    switch(handle) {
                        case 'nw': handleEl.style.cssText += 'top: -6px; left: -6px;'; break;
                        case 'ne': handleEl.style.cssText += 'top: -6px; right: -6px;'; break;
                        case 'sw': handleEl.style.cssText += 'bottom: -6px; left: -6px;'; break;
                        case 'se': handleEl.style.cssText += 'bottom: -6px; right: -6px;'; break;
                        case 'n': handleEl.style.cssText += 'top: -6px; left: 50%; margin-left: -6px;'; break;
                        case 's': handleEl.style.cssText += 'bottom: -6px; left: 50%; margin-left: -6px;'; break;
                        case 'w': handleEl.style.cssText += 'top: 50%; left: -6px; margin-top: -6px;'; break;
                        case 'e': handleEl.style.cssText += 'top: 50%; right: -6px; margin-top: -6px;'; break;
                    }

                    // Add resize functionality
                    handleEl.addEventListener('mousedown', (e) => startResize(e, handle));
                    overlay.appendChild(handleEl);
                });

                document.body.appendChild(overlay);
                return overlay;
            }

            // Create resize toolbar
            function createResizeToolbar() {
                const toolbar = document.createElement('div');
                toolbar.className = 'image-resize-toolbar';
                toolbar.style.cssText = `
                    position: absolute;
                    background: #6c5ce7;
                    border-radius: 8px;
                    padding: 8px;
                    display: none;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    z-index: 1002;
                    font-family: Arial, sans-serif;
                    white-space: nowrap;
                `;

                // Size buttons
                const sizes = [
                    { label: '25%', value: 0.25 },
                    { label: '50%', value: 0.5 },
                    { label: '75%', value: 0.75 },
                    { label: '100%', value: 1 },
                    { label: 'Auto', value: 'auto' }
                ];

                sizes.forEach(size => {
                    const btn = document.createElement('button');
                    btn.textContent = size.label;
                    btn.style.cssText = `
                        background: white;
                        border: none;
                        padding: 6px 12px;
                        margin: 0 2px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        font-weight: 500;
                        color: #6c5ce7;
                        transition: all 0.2s ease;
                    `;

                    btn.addEventListener('mouseenter', () => {
                        btn.style.background = '#f0f0f0';
                    });
                    
                    btn.addEventListener('mouseleave', () => {
                        btn.style.background = 'white';
                    });

                                         btn.addEventListener('click', (e) => {
                         e.preventDefault();
                         e.stopPropagation();
                         console.log('üîò Size button clicked:', size.label, size.value);
                         if (selectedImage) {
                             console.log('üñºÔ∏è Selected image:', selectedImage);
                             resizeImageToPercentage(size.value);
                         } else {
                             console.warn('‚ö†Ô∏è No image selected');
                         }
                     });

                    toolbar.appendChild(btn);
                });

                // Add separator
                const separator = document.createElement('div');
                separator.style.cssText = `
                    width: 1px;
                    height: 20px;
                    background: rgba(255,255,255,0.3);
                    margin: 0 8px;
                    display: inline-block;
                    vertical-align: middle;
                `;
                toolbar.appendChild(separator);

                // Alignment buttons
                const alignments = [
                    { label: '‚Üê', align: 'left', title: 'Align Left' },
                    { label: '‚Üï', align: 'center', title: 'Center' },
                    { label: '‚Üí', align: 'right', title: 'Align Right' }
                ];

                alignments.forEach(alignment => {
                    const btn = document.createElement('button');
                    btn.textContent = alignment.label;
                    btn.title = alignment.title;
                    btn.style.cssText = `
                        background: white;
                        border: none;
                        padding: 6px 8px;
                        margin: 0 2px;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 12px;
                        color: #6c5ce7;
                        transition: all 0.2s ease;
                    `;

                    btn.addEventListener('mouseenter', () => {
                        btn.style.background = '#f0f0f0';
                    });
                    
                    btn.addEventListener('mouseleave', () => {
                        btn.style.background = 'white';
                    });

                    btn.addEventListener('click', () => {
                        if (selectedImage) {
                            alignImage(alignment.align);
                        }
                    });

                    toolbar.appendChild(btn);
                });

                document.body.appendChild(toolbar);
                return toolbar;
            }

            // Get cursor for resize handle
            function getHandleCursor(handle) {
                const cursors = {
                    'nw': 'nw-resize', 'ne': 'ne-resize',
                    'sw': 'sw-resize', 'se': 'se-resize',
                    'n': 'n-resize', 's': 's-resize',
                    'w': 'w-resize', 'e': 'e-resize'
                };
                return cursors[handle] || 'default';
            }

            // Show resize overlay and toolbar
            function showImageResize(img) {
                selectedImage = img;
                
                if (!resizeOverlay) {
                    resizeOverlay = createResizeOverlay();
                }
                if (!resizeToolbar) {
                    resizeToolbar = createResizeToolbar();
                }

                // Position overlay
                const rect = img.getBoundingClientRect();
                const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
                const scrollY = window.pageYOffset || document.documentElement.scrollTop;

                resizeOverlay.style.display = 'block';
                resizeOverlay.style.left = (rect.left + scrollX) + 'px';
                resizeOverlay.style.top = (rect.top + scrollY) + 'px';
                resizeOverlay.style.width = rect.width + 'px';
                resizeOverlay.style.height = rect.height + 'px';

                // Position toolbar
                resizeToolbar.style.display = 'block';
                resizeToolbar.style.left = (rect.left + scrollX) + 'px';
                resizeToolbar.style.top = (rect.top + scrollY - 50) + 'px';

                console.log('‚úÖ Image resize overlay shown');
            }

            // Hide resize overlay and toolbar
            function hideImageResize() {
                if (resizeOverlay) {
                    resizeOverlay.style.display = 'none';
                }
                if (resizeToolbar) {
                    resizeToolbar.style.display = 'none';
                }
                selectedImage = null;
            }

            // Start resize operation
            function startResize(e, handle) {
                if (!selectedImage) return;
                
                e.preventDefault();
                e.stopPropagation();
                isResizing = true;

                console.log('üîÑ Starting resize with handle:', handle);

                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = selectedImage.offsetWidth;
                const startHeight = selectedImage.offsetHeight;
                const aspectRatio = startWidth / startHeight;

                console.log('üìè Initial dimensions:', { startWidth, startHeight, aspectRatio });

                function handleMouseMove(e) {
                    if (!isResizing) return;

                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    
                    let newWidth = startWidth;
                    let newHeight = startHeight;

                    // Calculate new dimensions based on handle
                    switch(handle) {
                        case 'se': // Southeast handle
                            newWidth = Math.max(50, startWidth + deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 'sw': // Southwest handle
                            newWidth = Math.max(50, startWidth - deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 'ne': // Northeast handle
                            newWidth = Math.max(50, startWidth + deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 'nw': // Northwest handle
                            newWidth = Math.max(50, startWidth - deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 'e': // East handle
                            newWidth = Math.max(50, startWidth + deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 'w': // West handle
                            newWidth = Math.max(50, startWidth - deltaX);
                            newHeight = newWidth / aspectRatio;
                            break;
                        case 's': // South handle
                            newHeight = Math.max(30, startHeight + deltaY);
                            newWidth = newHeight * aspectRatio;
                            break;
                        case 'n': // North handle
                            newHeight = Math.max(30, startHeight - deltaY);
                            newWidth = newHeight * aspectRatio;
                            break;
                    }

                    console.log('üìê New dimensions:', { newWidth, newHeight, deltaX, deltaY });

                    // Apply new dimensions with !important to override any CSS
                    selectedImage.style.setProperty('width', newWidth + 'px', 'important');
                    selectedImage.style.setProperty('height', newHeight + 'px', 'important');
                    selectedImage.style.setProperty('max-width', 'none', 'important');
                    selectedImage.style.setProperty('max-height', 'none', 'important');

                    // Update overlay position
                    setTimeout(() => showImageResize(selectedImage), 0);
                }

                function handleMouseUp() {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    document.body.style.cursor = 'default';
                    console.log('‚úÖ Image resize completed');
                }

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                document.body.style.cursor = getHandleCursor(handle);
            }

            // Resize image to percentage
            function resizeImageToPercentage(value) {
                if (!selectedImage) return;

                console.log('üîÑ Resizing image to:', value);

                if (value === 'auto') {
                    selectedImage.style.removeProperty('width');
                    selectedImage.style.removeProperty('height');
                    selectedImage.style.setProperty('max-width', '100%', 'important');
                    selectedImage.style.removeProperty('max-height');
                } else {
                    const containerWidth = selectedImage.parentElement.offsetWidth || 800;
                    const newWidth = containerWidth * value;
                    
                    // Use natural dimensions if available, otherwise calculate from current
                    let aspectRatio;
                    if (selectedImage.naturalWidth && selectedImage.naturalHeight) {
                        aspectRatio = selectedImage.naturalWidth / selectedImage.naturalHeight;
                    } else {
                        aspectRatio = selectedImage.offsetWidth / selectedImage.offsetHeight;
                    }
                    
                    const newHeight = newWidth / aspectRatio;
                    
                    console.log('üìê Container width:', containerWidth, 'New dimensions:', { newWidth, newHeight });
                    
                    selectedImage.style.setProperty('width', newWidth + 'px', 'important');
                    selectedImage.style.setProperty('height', newHeight + 'px', 'important');
                    selectedImage.style.setProperty('max-width', 'none', 'important');
                    selectedImage.style.setProperty('max-height', 'none', 'important');
                }

                console.log('‚úÖ Image resized to percentage');

                // Update overlay
                setTimeout(() => showImageResize(selectedImage), 50);
            }

            // Align image
            function alignImage(alignment) {
                if (!selectedImage) return;

                selectedImage.style.display = 'block';
                switch(alignment) {
                    case 'left':
                        selectedImage.style.marginLeft = '0';
                        selectedImage.style.marginRight = 'auto';
                        break;
                    case 'center':
                        selectedImage.style.marginLeft = 'auto';
                        selectedImage.style.marginRight = 'auto';
                        break;
                    case 'right':
                        selectedImage.style.marginLeft = 'auto';
                        selectedImage.style.marginRight = '0';
                        break;
                }
                console.log(`‚úÖ Image aligned to ${alignment}`);
            }

            // Add click handler to images
            quill.root.addEventListener('click', (e) => {
                if (e.target.tagName === 'IMG') {
                    e.preventDefault();
                    showImageResize(e.target);
                } else if (!e.target.closest('.image-resize-overlay') && !e.target.closest('.image-resize-toolbar')) {
                    hideImageResize();
                }
            });

            // Hide on scroll
            window.addEventListener('scroll', hideImageResize);
            quill.root.addEventListener('scroll', hideImageResize);

            // Hide when clicking elsewhere
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.ql-editor img') && 
                    !e.target.closest('.image-resize-overlay') && 
                    !e.target.closest('.image-resize-toolbar')) {
                    hideImageResize();
                }
            });

            console.log('‚úÖ Custom image resize functionality initialized');
        }

        // Add CSS for image resize functionality
        const imageResizeStyles = document.createElement('style');
        imageResizeStyles.textContent = `
            .ql-editor img {
                transition: all 0.3s ease;
                cursor: pointer;
                /* Remove conflicting size constraints */
            }
            
            .ql-editor img:hover {
                box-shadow: 0 0 0 2px rgba(108, 92, 231, 0.3);
                border-radius: 4px;
            }
            
            .image-resize-overlay {
                user-select: none;
                pointer-events: none;
            }
            
            .resize-handle {
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                transition: all 0.2s ease;
            }
            
            .resize-handle:hover {
                transform: scale(1.2);
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
            
            .image-resize-toolbar {
                user-select: none;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            }
            
            .image-resize-toolbar button:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            
            .image-resize-toolbar button:active {
                transform: translateY(0);
            }
            
            @media (max-width: 768px) {
                .image-resize-toolbar {
                    transform: scale(0.9);
                }
                
                .resize-handle {
                    width: 16px;
                    height: 16px;
                }
            }
        `;
        document.head.appendChild(imageResizeStyles);

        // Initialize custom resize functionality
        setTimeout(() => {
            setupImageResize();
        }, 1000);

        // Add global test functions for debugging
        window.testImageResize = function() {
            const images = document.querySelectorAll('.ql-editor img');
            if (images.length > 0) {
                const img = images[0];
                console.log('üß™ Testing resize on first image:', img);
                img.style.setProperty('width', '200px', 'important');
                img.style.setProperty('height', '150px', 'important');
                console.log('‚úÖ Test resize applied');
            } else {
                console.log('‚ùå No images found to test');
            }
        };

        window.debugImageStyles = function() {
            const images = document.querySelectorAll('.ql-editor img');
            images.forEach((img, index) => {
                console.log(`Image ${index + 1}:`, {
                    width: img.style.width,
                    height: img.style.height,
                    offsetWidth: img.offsetWidth,
                    offsetHeight: img.offsetHeight,
                    naturalWidth: img.naturalWidth,
                    naturalHeight: img.naturalHeight,
                    computedStyle: window.getComputedStyle(img)
                });
            });
        };

        // Create Add to Chat button
        const addToChatButton = document.createElement('button');
        addToChatButton.className = 'add-to-chat-button';
        addToChatButton.innerHTML = '<i class="fas fa-comment"></i> Add to Chat';
        addToChatButton.style.display = 'none';
        document.body.appendChild(addToChatButton);

        // Handle text selection in Quill editor
        quill.on('selection-change', function(range, oldRange, source) {
            if (range && range.length > 0) {
                // Text is selected
                const selectedText = quill.getText(range.index, range.length).trim();
                
                if (selectedText.length > 0) {
                    // Get the selection coordinates
                    const bounds = quill.getBounds(range.index, range.length);
                    const editorRect = quill.root.getBoundingClientRect();
                    
                    // Position the button above the selection
                    const buttonX = editorRect.left + bounds.left;
                    const buttonY = editorRect.top + bounds.top - 40; // 40px above selection
                    
                    addToChatButton.style.left = buttonX + 'px';
                    addToChatButton.style.top = buttonY + 'px';
                    addToChatButton.style.display = 'flex';
                    
                    // Add click handler
                    addToChatButton.onclick = function() {
                        addSelectedTextToChat(selectedText);
                        hideAddToChatButton();
                    };
                    
                    // Show the button with animation
                    setTimeout(() => {
                        addToChatButton.classList.add('show');
                    }, 10);
                } else {
                    hideAddToChatButton();
                }
            } else {
                hideAddToChatButton();
            }
        });

        // Function to hide the Add to Chat button
        function hideAddToChatButton() {
            addToChatButton.classList.remove('show');
            setTimeout(() => {
                addToChatButton.style.display = 'none';
            }, 300);
        }

        // Function to add selected text to chat input
        function addSelectedTextToChat(selectedText) {
            const chatInput = document.getElementById('user-input');
            if (chatInput) {
                // If there's already text in the input, add a space before the new text
                const currentValue = chatInput.value.trim();
                const newValue = currentValue ? currentValue + ' ' + selectedText : selectedText;
                
                chatInput.value = newValue;
                
                // Trigger input event to update any listeners
                chatInput.dispatchEvent(new Event('input', { bubbles: true }));
                
                // Focus on the chat input
                chatInput.focus();
                
                // Show a brief notification
                showNotification('Text added to chat input!', 'success');
                
                console.log('‚úÖ Selected text added to chat input:', selectedText);
            }
        }

        // Function to show notifications
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 65px;
                right: 20px;
                background: ${type === 'success' ? '#00b894' : '#6c5ce7'};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                transform: translateX(100%);
                transition: transform 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // Hide button when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.add-to-chat-button') && !e.target.closest('.ql-editor')) {
                hideAddToChatButton();
            }
        });

        // Hide button on scroll
        quill.root.addEventListener('scroll', hideAddToChatButton);



        // Auto-save functionality
        let autoSaveTimeout = null;
        let lastSavedContent = '';
        let isAutoSaving = false;

        // Function to auto-save blog content
        const autoSaveBlog = async () => {
            if (isAutoSaving) return;
            
            const currentContent = quill.root.innerHTML;
            const currentBlogId = localStorage.getItem('currentBlogId');
            
            // Don't save if content hasn't changed or if no blog ID
            if (currentContent === lastSavedContent || !currentBlogId) {
                return;
            }

            // Don't save if content is just the placeholder
            if (currentContent === '<h2>Write a blog here or generate a blog using the chat section</h2>') {
                return;
            }

            isAutoSaving = true;
            
            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    console.warn('No authentication token found for auto-save');
                    return;
                }

                // Extract blog title and summary
                const title = extractBlogTitle(currentContent);
                const summary = extractBlogPreview(currentContent);

                const response = await fetch(`${API_URL}/blogs/${currentBlogId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        content: currentContent,
                        title: title,
                        summary: summary,
                        lastModified: new Date().toISOString()
                    })
                });

                if (response.ok) {
                    lastSavedContent = currentContent;
                    console.log('‚úÖ Blog auto-saved successfully');
                    
                    // Update history modal if it's open
                    updateHistoryModal();
                    
                    // Show subtle save indicator
                    showSaveIndicator();
                } else {
                    console.error('‚ùå Auto-save failed:', response.status);
                }
            } catch (error) {
                console.error('‚ùå Auto-save error:', error);
            } finally {
                isAutoSaving = false;
            }
        };

        // Function to show save indicator
        const showSaveIndicator = () => {
            // Create or update save indicator
            let saveIndicator = document.getElementById('save-indicator');
            if (!saveIndicator) {
                saveIndicator = document.createElement('div');
                saveIndicator.id = 'save-indicator';
                saveIndicator.style.cssText = `
                    position: fixed;
                    top: 65px;
                    right: 20px;
                    background: #00b894;
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: 500;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 8px rgba(0, 184, 148, 0.3);
                    pointer-events: none;
                `;
                document.body.appendChild(saveIndicator);
            }
            
            saveIndicator.textContent = 'üíæ Auto-saved';
            saveIndicator.style.opacity = '1';
            saveIndicator.style.transform = 'translateY(0)';
            
            // Hide after 2 seconds
            setTimeout(() => {
                saveIndicator.style.opacity = '0';
                saveIndicator.style.transform = 'translateY(-10px)';
            }, 2000);
        };

        // Function to show manual save indicator
        const showManualSaveIndicator = () => {
            let saveIndicator = document.getElementById('save-indicator');
            if (!saveIndicator) {
                saveIndicator = document.createElement('div');
                saveIndicator.id = 'save-indicator';
                saveIndicator.style.cssText = `
                    position: fixed;
                    top: 65px;
                    right: 20px;
                    background: #6c5ce7;
                    color: white;
                    padding: 8px 16px;
                    border-radius: 20px;
                    font-size: 12px;
                    font-weight: 500;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                    box-shadow: 0 2px 8px rgba(108, 92, 231, 0.3);
                    pointer-events: none;
                `;
                document.body.appendChild(saveIndicator);
            }
            
            saveIndicator.textContent = 'üíæ Saved';
            saveIndicator.style.background = '#6c5ce7';
            saveIndicator.style.boxShadow = '0 2px 8px rgba(108, 92, 231, 0.3)';
            saveIndicator.style.opacity = '1';
            saveIndicator.style.transform = 'translateY(0)';
            
            // Hide after 2 seconds
            setTimeout(() => {
                saveIndicator.style.opacity = '0';
                saveIndicator.style.transform = 'translateY(-10px)';
            }, 2000);
        };

        // Function to display blog history
        async function displayBlogHistory() {
            try {
                const token = localStorage.getItem('token');
                const response = await fetch(`${API_URL}/blogs/user`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch blog history');
                }

                const data = await response.json();
                const blogs = data.data.blogs;
                
                const historyDropdownContent = document.getElementById('history-dropdown-content');
                if (!historyDropdownContent) return;
                
                historyDropdownContent.innerHTML = '';

                if (blogs.length === 0) {
                    historyDropdownContent.innerHTML = `
                        <div class="history-item" style="justify-content: center;">
                            <span style="color: #999;">No blogs found</span>
                        </div>
                    `;
                    return;
                }

                blogs.forEach(blog => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.innerHTML = `
                        <div class="history-item-content">
                            <div class="history-item-header">
                                <i class="fa-solid fa-file-lines"></i>
                                <span class="topic-title">${blog.title || 'Untitled Blog'}</span>
                            </div>
                            <div class="history-item-details">
                                <span class="topic-category">${blog.category}</span>
                                <span class="topic-date">${formatDate(blog.updatedAt || blog.createdAt)}</span>
                            </div>
                            <div class="history-item-preview">
                                ${blog.summary || 'No preview available'}
                            </div>
                        </div>
                    `;
                    
                    historyItem.addEventListener('click', async () => {
                        if (confirm('Load this blog? Current content and chat will be replaced.')) {
                            await window.loadBlogWithChatHistory(blog._id);
                            const historyDropdown = document.getElementById('history-dropdown');
                            if (historyDropdown) {
                                historyDropdown.classList.remove('show');
                            }
                        }
                    });

                    historyDropdownContent.appendChild(historyItem);
                });
            } catch (error) {
                console.error('Error fetching blog history:', error);
                showToast('Failed to load blog history', 'error');
            }
        }

        // Function to format date
        function formatDate(isoString) {
            const date = new Date(isoString);
            return date.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // Function to update history modal
        const updateHistoryModal = async () => {
            const historyDropdown = document.getElementById('history-dropdown');
            if (historyDropdown && historyDropdown.classList.contains('show')) {
                // Refresh the history list
                await displayBlogHistory();
            }
        };

        // Set up auto-save on content change
        quill.on('text-change', (delta, oldDelta, source) => {
            // Only auto-save if the change is from user input
            if (source === 'user') {
                // Clear existing timeout
                if (autoSaveTimeout) {
                    clearTimeout(autoSaveTimeout);
                }
                
                // Set new timeout for auto-save (2 seconds after last change)
                autoSaveTimeout = setTimeout(() => {
                    autoSaveBlog();
                }, 2000);
            }
        });

        // Also save on paste and image insert
        quill.on('paste', () => {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            autoSaveTimeout = setTimeout(() => {
                autoSaveBlog();
            }, 1000);
        });

        // Save before page unload
        window.addEventListener('beforeunload', () => {
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
                autoSaveBlog();
            }
        });

        // Manual save function
        window.manualSaveBlog = async () => {
            const currentContent = quill.root.innerHTML;
            const currentBlogId = localStorage.getItem('currentBlogId');
            
            if (!currentBlogId) {
                showToast('No blog to save. Please generate a blog first.', 'error');
                return;
            }

            if (currentContent === '<h2>Write a blog here or generate a blog using the chat section</h2>') {
                showToast('No content to save.', 'error');
                return;
            }

            try {
                const token = localStorage.getItem('token');
                if (!token) {
                    showToast('Please log in to save your blog.', 'error');
                    return;
                }

                // Extract blog title and summary
                const title = extractBlogTitle(currentContent);
                const summary = extractBlogPreview(currentContent);

                const response = await fetch(`${API_URL}/blogs/${currentBlogId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        content: currentContent,
                        title: title,
                        summary: summary,
                        lastModified: new Date().toISOString()
                    })
                });

                if (response.ok) {
                    lastSavedContent = currentContent;
                    showManualSaveIndicator();
                    
                    // Update history modal if it's open
                    updateHistoryModal();
                } else {
                    showToast('Failed to save blog. Please try again.', 'error');
                }
            } catch (error) {
                console.error('Manual save error:', error);
                showToast('Error saving blog. Please try again.', 'error');
            }
        };

        // Add keyboard shortcut for manual save (Ctrl+S)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                window.manualSaveBlog();
            }
        });

        // Constants
      const API_URL = "http://localhost:5000/api"; // For chat storage and auth
        
        // Function to check if backend is available
        async function checkBackendAvailability() {
            try {
                const response = await fetch(`${API_URL.replace('/api', '')}/health`, { 
                    method: 'GET',
                    timeout: 5000 
                });
                return response.ok;
            } catch (error) {
                console.warn('Backend server not available:', error.message);
                return false;
            }
        }
        
                 // Check backend availability on page load
         let backendAvailable = false;
         checkBackendAvailability().then(available => {
             backendAvailable = available;
             if (available) {
                 console.log('‚úÖ Backend server is available');
             } else {
                 console.log('‚ö†Ô∏è Backend server not available - some features may be limited');
                 // Show a non-intrusive notification
                 if (typeof showToast !== 'undefined') {
                     showToast('Backend server not available. Chat history will not be saved.', 'warning');
                 }
             }
         });

        // Add controller for cancellation
        let generationController = null;

// Function to reset conversation state for new blog generation
function resetConversationState() {
    isFirstPrompt = true;
    conversationStarted = false;
    currentBlogId = null;
        localStorage.removeItem("currentBlogId");
    
    // Clear restoration flag
    localStorage.removeItem("isRestoringChat");
    
    // Update global state
    window.isFirstPrompt = isFirstPrompt;
    window.conversationStarted = conversationStarted;
    window.currentBlogId = currentBlogId;
}

        // Make reset function globally accessible
        window.resetConversationState = resetConversationState;
        
        // Make functions globally accessible for debugging
        window.extractChatMessages = extractChatMessages;
        window.saveChatHistoryToBlog = saveChatHistoryToBlog;
        window.loadBlogWithChatHistory = window.loadChatHistory;
        
        // Add authentication debugging functions
        window.debugAuth = function() {
            console.log('üîê === AUTHENTICATION DEBUG ===');
            const token = localStorage.getItem("token");
            const userCookie = document.cookie
                .split(";")
                .find((cookie) => cookie.trim().startsWith("user="));
            
            console.log('Local Storage Token:', token ? 'EXISTS' : 'MISSING');
            console.log('User Cookie:', userCookie ? 'EXISTS' : 'MISSING');
            
            if (token) {
                console.log('Token length:', token.length);
                console.log('Token preview:', token.substring(0, 50) + '...');
                
                try {
                    const parts = token.split('.');
                    console.log('Token parts:', parts.length);
                    
                    if (parts.length === 3) {
                        const payload = JSON.parse(atob(parts[1]));
                        console.log('Token payload:', payload);
                        console.log('Token expires:', payload.exp ? new Date(payload.exp * 1000) : 'No expiration');
                        console.log('Is expired:', payload.exp ? (payload.exp < Math.floor(Date.now() / 1000)) : 'Unknown');
                    }
                } catch (error) {
                    console.error('Error parsing token:', error);
                }
            }
            
            console.log('Current URL:', window.location.href);
            console.log('All cookies:', document.cookie);
            console.log('=== END AUTH DEBUG ===');
        };
        
        window.clearAuth = function() {
            console.log('üßπ Clearing authentication data...');
            localStorage.removeItem("token");
            document.cookie = "user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            console.log('‚úÖ Authentication data cleared');
            console.log('Redirecting to login...');
            window.location.href = "login.html";
        };
        
        window.testAuth = function() {
            console.log('üß™ Testing authentication...');
            const authCheck = checkAuthToken();
            console.log('Auth check result:', authCheck);
            return authCheck;
        };
        
        window.testCORS = function(imageUrl) {
            console.log('üåê Testing CORS for image:', imageUrl);
            
            const testImg = new Image();
            testImg.crossOrigin = 'anonymous';
            
            testImg.onload = function() {
                console.log('‚úÖ CORS test successful - image loaded');
            };
            
            testImg.onerror = function() {
                console.log('‚ùå CORS test failed - image blocked');
                console.log('Try adding this URL to your S3 CORS configuration');
            };
            
            testImg.src = imageUrl;
        };
        
        // Function to manually clear input field
        window.clearInput = function() {
            const userInput = document.getElementById("user-input");
            if (userInput) {
                userInput.value = "";
                userInput.dispatchEvent(new Event('input', { bubbles: true }));
                console.log('üßπ Input manually cleared');
            } else {
                console.log('‚ùå Input field not found');
            }
        };
        
        // Function to check input field status
        window.checkInput = function() {
            const userInput = document.getElementById("user-input");
            if (userInput) {
                console.log('üìù Input field status:');
                console.log('Value:', userInput.value);
                console.log('Placeholder:', userInput.placeholder);
                console.log('Is focused:', document.activeElement === userInput);
            } else {
                console.log('‚ùå Input field not found');
            }
        };
        
        // Chat history management functions
        window.saveChatHistoryNow = function() {
            saveChatHistory();
            console.log('üíæ Chat history manually saved');
        };
        
        window.loadChatHistoryNow = function() {
            loadChatHistory();
            console.log('üìÇ Chat history manually loaded');
        };
        
        window.clearChatHistory = function() {
            localStorage.removeItem('chatHistory');
            console.log('üóëÔ∏è Chat history cleared from localStorage');
            
            // Also clear the chat display
            const chatMessages = document.getElementById("chat-messages");
            while (chatMessages.children.length > 1) {
                chatMessages.removeChild(chatMessages.lastChild);
            }
            console.log('üóëÔ∏è Chat display cleared');
        };
        
        window.showChatHistoryInfo = function() {
            const savedHistory = localStorage.getItem('chatHistory');
            if (savedHistory) {
                const messages = JSON.parse(savedHistory);
                console.log('üìä Chat History Info:');
                console.log('Total messages:', messages.length);
                console.log('User messages:', messages.filter(m => m.isUser).length);
                console.log('AI messages:', messages.filter(m => !m.isUser).length);
                console.log('Messages with images:', messages.filter(m => m.images && m.images.length > 0).length);
                console.log('Storage size:', (savedHistory.length / 1024).toFixed(2) + ' KB');
            } else {
                console.log('üìä No chat history found in localStorage');
            }
        };
        
        // Add function to test current chat state
      window.testCurrentChatImages = function () {
        ("=== Testing current chat images ===");
        const chatMessages = document.getElementById("chat-messages");
            const allMessages = chatMessages.children;
            
            for (let i = 0; i < allMessages.length; i++) {
                const messageWrapper = allMessages[i];
          const generatedImages =
            messageWrapper.querySelector(".generated-images");
          const messageContent =
            messageWrapper.querySelector(".message-content p");
                
                if (generatedImages) {
            const images = generatedImages.querySelectorAll("img");
                    
            "- Image URLs:", Array.from(images).map((img) => img.src);
                }
            }
        };

        // Add debug function to test chat restoration
      window.debugChatRestoration = async function () {
        const currentBlogId = localStorage.getItem("currentBlogId");
            if (!currentBlogId) {
                return;
            }
            
        ("=== Debug: Testing chat restoration ===");
            
            // Test extraction
            const extracted = extractChatMessages();
            
            // Test API call
            try {
          const token = localStorage.getItem("token");
          const response = await fetch(
            `${API_URL}/blogs/${currentBlogId}/with-chat`,
            {
              headers: { Authorization: `Bearer ${token}` },
            }
          );
                const data = await response.json();
                
          "Stored chat history:", data.data?.blog?.chatHistory;
            } catch (error) {
          console.error("Error fetching blog data:", error);
            }
        };
        
        // Add function to check what's currently in chat DOM
      window.inspectCurrentChatDOM = function () {
        const chatMessages = document.getElementById("chat-messages");
            Array.from(chatMessages.children).forEach((wrapper, index) => {
          const images = wrapper.querySelectorAll(".generated-images img");
                if (images.length > 0) {
                }
            });
        };

        // Add function to manually test image addition
      window.testAddImageToChat = async function () {
        const testImageUrls = [
          "https://via.placeholder.com/200x200/0000FF/FFFFFF?text=Test+Image",
        ];
            
            await addMessageToChat("Test image message", false, testImageUrls);
            
            window.inspectCurrentChatDOM();
            
        ("Testing extraction after addition...");
            const extracted = extractChatMessages();
            const lastMessage = extracted[extracted.length - 1];
        };

        // Add comprehensive test function
      window.testImageRestorationWorkflow = async function () {
            // Step 1: Check current chat DOM
            
            window.inspectCurrentChatDOM();
            
            // Step 2: Test extraction
        ("Step 2: Testing extraction");
            const extracted = extractChatMessages();
            
            extracted.forEach((msg, index) => {
                if (msg.metadata) {
                }
            });
            
            // Step 3: Check what's in database
        const currentBlogId = localStorage.getItem("currentBlogId");
            if (currentBlogId) {
                await window.checkBlogChatHistory(currentBlogId);
            } else {
            }
        };

        // Add function to check specific blog's chat history
      window.checkBlogChatHistory = async function (blogId) {
            if (!blogId) {
                return;
            }
            
        ("=== Checking blog chat history ===");
            
            try {
          const token = localStorage.getItem("token");
                
                // Check with debug endpoint
          const debugResponse = await fetch(
            `${API_URL}/blogs/${blogId}/debug`,
            {
              headers: { Authorization: `Bearer ${token}` },
            }
          );
                const debugData = await debugResponse.json();
                
                // Check with regular endpoint
                const regularResponse = await fetch(`${API_URL}/blogs/${blogId}`, {
            headers: { Authorization: `Bearer ${token}` },
                });
                const regularData = await regularResponse.json();
          "Regular endpoint data:", regularData;
                
                // Check with with-chat endpoint
          const chatResponse = await fetch(
            `${API_URL}/blogs/${blogId}/with-chat`,
            {
              headers: { Authorization: `Bearer ${token}` },
            }
          );
                const chatData = await chatResponse.json();
            } catch (error) {
          console.error("Error checking blog chat history:", error);
            }
        };

        // Enhanced debug function to test metadata parsing
      window.debugMetadataParsing = function (metadata) {
            if (metadata) {
                // Test different access patterns
                
                // Test iteration
                for (const [key, value] of Object.entries(metadata)) {
                    if (Array.isArray(value)) {
            } else if (value && typeof value === "object") {
                    }
                }
            }
        };

        // Test function to simulate image restoration with known data
      window.testImageRestoration = function () {
            // Create test data that matches what should be coming from backend
            const testImageUrls = [
          "https://example.com/test-image-1.jpg",
          "https://example.com/test-image-2.jpg",
            ];
            
            const testMessage = {
          content: "Image generated successfully!",
          type: "ai",
                timestamp: new Date(),
                metadata: {
            imageUrls: testImageUrls,
          },
            };
            
            // Test the restoration logic
            let imageUrls = null;
            if (testMessage.metadata) {
                if (testMessage.metadata.imageUrls) {
                    imageUrls = testMessage.metadata.imageUrls;
          } else if (
            testMessage.metadata._doc &&
            testMessage.metadata._doc.imageUrls
          ) {
                    imageUrls = testMessage.metadata._doc.imageUrls;
          } else if (typeof testMessage.metadata === "object") {
                    const metadataValues = Object.values(testMessage.metadata);
                    for (const value of metadataValues) {
              if (
                Array.isArray(value) &&
                value.length > 0 &&
                typeof value[0] === "string" &&
                value[0].includes("http")
              ) {
                            imageUrls = value;
                            break;
                        }
                    }
                }
            }
            
            if (imageUrls) {
          if (typeof imageUrls === "string") {
                    imageUrls = [imageUrls];
          } else if (
            typeof imageUrls === "object" &&
            !Array.isArray(imageUrls)
          ) {
                    imageUrls = Object.values(imageUrls);
                }
            }
            
        const hasImages =
          imageUrls && Array.isArray(imageUrls) && imageUrls.length > 0;
            
            if (hasImages) {
          const imageElements = imageUrls
            .map(
              (url) =>
                    `<img src="${url}" alt="Generated Image" style="max-width: 100%; height: auto; border-radius: 8px; margin: 5px;">`
            )
            .join("");
                
                const imageContainer = `<div class="generated-images" style="margin: 10px 0;">${imageElements}</div>`;
                
                // Test adding to chat
          const chatContainer = document.getElementById("chat-container");
                if (chatContainer) {
            const testDiv = document.createElement("div");
                    testDiv.innerHTML = `
                        <div class="message ai-message">
                            <div class="message-content">
                                ${testMessage.content}
                                ${imageContainer}
                            </div>
                        </div>
                    `;
                    chatContainer.appendChild(testDiv);
                } else {
            console.error("Chat container not found");
                }
            }
        };

        // Function to inspect actual restoration data
      window.inspectRestorationData = async function (blogId) {
            try {
          const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}/with-chat`, {
            headers: { Authorization: `Bearer ${token}` },
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                const chatHistory = data.data?.blog?.chatHistory || [];
                
                // Find messages with metadata
          const messagesWithMetadata = chatHistory.filter(
            (msg) => msg.metadata && Object.keys(msg.metadata).length > 0
          );
                
                messagesWithMetadata.forEach((msg, index) => {
                    // Test the actual parsing logic on this real data
                    debugMetadataParsing(msg.metadata);
                });
                
                // Test restoration on real data
                if (messagesWithMetadata.length > 0) {
                    const testMsg = messagesWithMetadata[0];
                    
                    // Copy the exact restoration logic
                    let imageUrls = null;
                    if (testMsg.metadata) {
                        if (testMsg.metadata.imageUrls) {
                            imageUrls = testMsg.metadata.imageUrls;
              } else if (
                testMsg.metadata._doc &&
                testMsg.metadata._doc.imageUrls
              ) {
                            imageUrls = testMsg.metadata._doc.imageUrls;
              } else if (typeof testMsg.metadata === "object") {
                            const metadataValues = Object.values(testMsg.metadata);
                            for (const value of metadataValues) {
                  if (
                    Array.isArray(value) &&
                    value.length > 0 &&
                    typeof value[0] === "string" &&
                    value[0].includes("http")
                  ) {
                                    imageUrls = value;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (imageUrls) {
              if (typeof imageUrls === "string") {
                            imageUrls = [imageUrls];
              } else if (
                typeof imageUrls === "object" &&
                !Array.isArray(imageUrls)
              ) {
                            imageUrls = Object.values(imageUrls);
                        }
                    }
                    
            const hasImages =
              imageUrls && Array.isArray(imageUrls) && imageUrls.length > 0;
                }
            } catch (error) {
          console.error("Error inspecting restoration data:", error);
            }
        };

// This function has been replaced by handleSendMessage for better flow control

// Handle first prompt (full blog generation)
async function handleFirstPrompt(prompt) {
    try {
        // Show loading overlay
          document.getElementById("loading-overlay").style.display = "flex";
        
        // Add loading message
          await addMessageToChat(
            "üîç Generating keywords and content for your blog...",
            false
          );
        
        // Generate keywords first
        await getKeywords(prompt);
        
        // Generate blog content
        const content = await generateContent(prompt);
        
        if (content) {
            // Update editor
            quill.root.innerHTML = content;
            localStorage.setItem("BlogGenerated", content);
            
            // Update conversation state
            isFirstPrompt = false;
            conversationStarted = true;
            
            // Update global state
            window.isFirstPrompt = isFirstPrompt;
            window.conversationStarted = conversationStarted;
            
            // Add success message
            await addMessageToChat(
              "‚úÖ Blog generated successfully! You can now ask me to modify specific sections or add more content.",
              false
            );
            
            // Auto-save the blog with current chat messages
            const savedBlog = await autoSaveBlogToMongoDB(content, prompt);
            
            // Set the current blog ID if this is a new blog
            if (savedBlog && savedBlog._id) {
                currentBlogId = savedBlog._id;
              localStorage.setItem("currentBlogId", savedBlog._id);
                window.currentBlogId = currentBlogId;
                
                // Save current chat history to the blog
                await saveChatHistoryToBlog();
            }
        }
    } catch (error) {
          console.error("Error in first prompt handling:", error);
          await addMessageToChat(
            "Sorry, there was an error generating your blog. Please try again.",
            false
          );
    } finally {
        // Hide loading overlay
          document.getElementById("loading-overlay").style.display = "none";
        }
      }
// Validate current blog ID on page load
async function validateCurrentBlogId() {
        const currentBlogId = localStorage.getItem("currentBlogId");
    if (currentBlogId) {
        try {
            const token = localStorage.getItem("token");
            const response = await fetch(`${API_URL}/blogs/${currentBlogId}`, {
                headers: {
                Authorization: `Bearer ${token}`,
              },
            });
            
            if (response.status === 404) {
              console.warn(
                "Stored blog ID not found, clearing from localStorage"
              );
              localStorage.removeItem("currentBlogId");
                window.currentBlogId = null;
            }
        } catch (error) {
            console.warn("Error validating stored blog ID:", error);
            localStorage.removeItem("currentBlogId");
            window.currentBlogId = null;
        }
    }
}

    // Load saved content when page loads
      document.addEventListener("DOMContentLoaded", function () {
        // Helper function to check jsPDF availability
        window.isjsPDFAvailable = function() {
            return typeof jsPDF !== 'undefined' || typeof window.jsPDF !== 'undefined';
        };
        
        // Helper function to get jsPDF constructor
        window.getjsPDFConstructor = function() {
            if (typeof jsPDF !== 'undefined') {
                return jsPDF;
            } else if (typeof window.jsPDF !== 'undefined') {
                return window.jsPDF;
            } else {
                throw new Error('jsPDF not available');
            }
        };
        
        // Check jsPDF library loading
        setTimeout(() => {
            if (window.isjsPDFAvailable()) {
                console.log("‚úÖ jsPDF library loaded and available");
            } else {
                console.error("‚ùå jsPDF library not found - PDF generation will not work");
            }
        }, 2000); // Wait 2 seconds for all checks to complete
        
    // Validate stored blog ID first
    validateCurrentBlogId();
    // Initialize history button
        const historyButton = document.getElementById("history-button");
    if (historyButton) {
          historyButton.addEventListener("click", async function (e) {
            e.preventDefault();
            
            // Show loading state on button
            const originalContent = historyButton.innerHTML;
            historyButton.innerHTML = `
                <i class="fa-solid fa-spinner fa-spin"></i>
                <span>Loading...</span>
            `;
            historyButton.disabled = true;
            
            try {
                await showHistoryModal();
            } catch (error) {
                console.error("Error showing history modal:", error);
            } finally {
                // Restore original button state
                historyButton.innerHTML = originalContent;
                historyButton.disabled = false;
            }
        });
    }

    // Function to show confirmation toast
    function showConfirmationToast(message, onConfirm) {
        // Create a custom confirmation toast
        const toastContainer = document.createElement('div');
        toastContainer.style.cssText = `
            position: fixed;
            top: 65px;
            right: 20px;
            background: linear-gradient(135deg, #6c5ce7, #5f4dd0);
            color: white;
            padding: 16px 20px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            z-index: 10000;
            box-shadow: 0 8px 25px rgba(108, 92, 231, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        `;
        
        // Message text
        const messageText = document.createElement('div');
        messageText.textContent = message;
        messageText.style.cssText = `
            line-height: 1.4;
            margin-bottom: 8px;
        `;
        
        // Buttons container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.cssText = `
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        `;
        
        // Cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = `
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        `;
        cancelBtn.onmouseover = () => cancelBtn.style.background = 'rgba(255, 255, 255, 0.3)';
        cancelBtn.onmouseout = () => cancelBtn.style.background = 'rgba(255, 255, 255, 0.2)';
        
        // Confirm button
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.style.cssText = `
            background: #00b894;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s ease;
        `;
        confirmBtn.onmouseover = () => confirmBtn.style.background = '#00a085';
        confirmBtn.onmouseout = () => confirmBtn.style.background = '#00b894';
        
        // Add event listeners
        cancelBtn.addEventListener('click', () => {
            hideConfirmationToast();
        });
        
        confirmBtn.addEventListener('click', () => {
            hideConfirmationToast();
            if (onConfirm) onConfirm();
        });
        
        // Assemble the toast
        buttonsContainer.appendChild(cancelBtn);
        buttonsContainer.appendChild(confirmBtn);
        toastContainer.appendChild(messageText);
        toastContainer.appendChild(buttonsContainer);
        
        // Add to page
        document.body.appendChild(toastContainer);
        
        // Animate in
        setTimeout(() => {
            toastContainer.style.transform = 'translateX(0)';
        }, 10);
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            if (toastContainer.parentNode) {
                hideConfirmationToast();
            }
        }, 10000);
        
        // Store reference for hiding
        window.currentConfirmationToast = toastContainer;
    }
    
    // Function to hide confirmation toast
    function hideConfirmationToast() {
        const toast = window.currentConfirmationToast;
        if (toast && toast.parentNode) {
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
                window.currentConfirmationToast = null;
            }, 300);
        }
    }
    
    // Function to show toast messages
    function showToast(message, type = 'success') {
        const backgroundColor = type === 'success' ? '#00b894' : 
                              type === 'error' ? '#e74c3c' : 
                              type === 'warning' ? '#f39c12' :
                              '#6c5ce7';
        
        Toastify({
            text: message,
            duration: 3000,
            gravity: "bottom",
            position: "right",
            style: {
                background: backgroundColor,
                boxShadow: '0 3px 10px rgba(0, 0, 0, 0.2)',
                borderRadius: '8px',
                fontWeight: '500'
            },
            offset: {
                x: 20,
                y: 20
            },
            stopOnFocus: true,
        }).showToast();
    }

    // Initialize new blog button
        const newBlogButton = document.getElementById("new-blog-button");
    if (newBlogButton) {
          newBlogButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Show confirmation toast instead of alert
            if (conversationStarted) {
                showConfirmationToast(
                    "Are you sure you want to start a new blog? This will clear your current content and chat history.",
                    () => {
                        // User confirmed - proceed with new blog
                        startNewBlog();
                    }
                );
                return;
            }
            
            // If no conversation started, proceed directly
            startNewBlog();
        });
    }
    
    // Function to start a new blog
    function startNewBlog() {
            
            // Reset conversation state
            resetConversationState();
            
            // Clear editor content
            quill.root.innerHTML =
              "<h2>Write a blog here or generate a blog using the chat section</h2>";
            
            // Clear localStorage - including chat history
            localStorage.removeItem("BlogGenerated");
            localStorage.removeItem("generatedKeywords");
            localStorage.removeItem("top50Keywords");
            localStorage.removeItem("currentBlogId");
            localStorage.removeItem("chatHistory"); // Clear chat history from localStorage
            localStorage.removeItem("previousBlogContent"); // Clear previous content for restore buttons
            
            // Clear any topic-specific generation flags
            const urlParams = new URLSearchParams(window.location.search);
            const currentTopic = urlParams.get("topic");
            if (currentTopic) {
                localStorage.removeItem(`blogGenerated_${currentTopic}`);
                console.log('üóëÔ∏è Cleared generation flag for topic:', currentTopic);
            }
            
            // Clear all topic generation flags (optional cleanup)
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('blogGenerated_')) {
                    localStorage.removeItem(key);
                }
            });
            
            // Clear restoration flag when starting new blog
            localStorage.removeItem("isRestoringChat");
            
            // Clear chat messages completely and add fresh welcome message
            const chatMessages = document.getElementById("chat-messages");
            chatMessages.innerHTML = ''; // Clear all messages including welcome message
            
            // Add fresh welcome message
            addMessageToChat(
              "‚ú® Ready to create a new blog! What topic would you like to write about?",
              false
            );
            
            // Reset Quill editor to default state
            if (quill) {
                quill.root.innerHTML = '<h2>Write a blog here or generate a blog using the chat section</h2>';
            }
            
            // Focus on chat input
            const chatInput = document.getElementById("user-input");
            if (chatInput) {
                chatInput.focus();
            }
            
            console.log('üîÑ New blog started - chat history and content cleared');
    }

    // Initialize history modal close buttons
        const closeHistoryModalBtn =
          document.getElementById("closeHistoryModal");
        const historyModalOverlay = document.getElementById(
          "historyModalOverlay"
        );
    
    if (closeHistoryModalBtn) {
          closeHistoryModalBtn.addEventListener("click", closeHistoryModal);
    }
    
    if (historyModalOverlay) {
          historyModalOverlay.addEventListener("click", closeHistoryModal);
    }

    // Load saved blog content
        const savedBlog = localStorage.getItem("BlogGenerated");
    if (savedBlog) {
        quill.root.innerHTML = savedBlog;
        // If there's saved content, set conversation as started but not first prompt
          if (
            savedBlog !==
            "<h2>Write a blog here or generate a blog using the chat section</h2>"
          ) {
            conversationStarted = true;
            isFirstPrompt = false;
            
            // Update global state
            window.conversationStarted = conversationStarted;
            window.isFirstPrompt = isFirstPrompt;
        }
    }
    
    // Process and store top 50 keywords
        const generatedKeywords = localStorage.getItem("generatedKeywords");
    if (generatedKeywords) {
        const top50 = getTopKeywords();
    } else {
    }
    
    // Load chat history only if no fresh topic is provided
    const urlParams = new URLSearchParams(window.location.search);
    const topic = urlParams.get("topic");
    
    if (!topic || topic.trim() === "") {
    loadChatHistory();
    } else {
        console.log('üîÑ Skipping chat history load due to fresh topic parameter');
    }
    
    // Initialize send button functionality
        const sendButton = document.querySelector(".send-button");
        const userInput = document.getElementById("user-input");
    
    if (sendButton && userInput) {
        // Send button click handler - use the main flow
          sendButton.addEventListener("click", async function () {
            await handleSendMessage();
        });
        
        // Enter key handler for textarea - use the main flow
          userInput.addEventListener("keydown", function (e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                console.log('‚èé Enter key pressed, calling handleSendMessage');
                handleSendMessage();
            }
        });
        
        // Also handle input clearing on blur and focus for better UX
        userInput.addEventListener("blur", function() {
            // Don't clear on blur, just log for debugging
            console.log('üëÅÔ∏è Input lost focus, current value:', userInput.value);
        });
        
        userInput.addEventListener("focus", function() {
            console.log('üëÅÔ∏è Input gained focus, current value:', userInput.value);
        });
    }
        // Initialize download button functionality with jsPDF
        const downloadButton = document.getElementById("download-button");
        if (downloadButton) {
            downloadButton.addEventListener("click", async function() {
                console.log('Download button clicked');
                
                // Check if jsPDF and html2canvas are available
                console.log('Checking PDF libraries...');
                console.log('jsPDF type:', typeof jsPDF);
                console.log('window.jsPDF type:', typeof window.jsPDF);
                console.log('html2canvas type:', typeof html2canvas);
                
                if (!window.isjsPDFAvailable()) {
                    console.error('jsPDF library not loaded');
                        showToast('PDF generation library not loaded. Please refresh the page and try again.', 'error');
                    return;
                        }
                
                if (typeof html2canvas === 'undefined') {
                    console.error('html2canvas library not loaded');
                    showToast('PDF generation library not loaded. Please refresh the page and try again.', 'error');
                    return;
                }
                
                console.log('‚úÖ Both libraries are available');
                
                // Get the Quill editor content
                let editorContent = document.querySelector('.ql-editor');
                console.log('Editor content element:', editorContent);

                // Fallback: try to get content from Quill instance if available
                if (!editorContent && window.quill) {
                    console.log('Using Quill instance to get content');
                    editorContent = window.quill.root;
                }

                if (!editorContent) {
                    console.error('No editor content found');
                    showToast('No content found to download. Please make sure the editor is loaded.', 'error');
                    return;
                }

                // Check if there's actual content (not just the placeholder)
                const content = editorContent.innerHTML;
                console.log('Content length:', content.length);
                console.log('Content preview:', content.substring(0, 100));
                
                if (content === '<h2>Write a blog here or generate a blog using the chat section</h2>' ||
                    content.trim() === '') {
                    console.log('Content is empty or placeholder');
                    showToast('Please generate or write some blog content before downloading.', 'error');
                    return;
                }

                // Declare variables outside try block for proper cleanup
                let tempContainer = null;
                let loadingMessage = null;

                // Show loading message
                loadingMessage = document.createElement('div');
                loadingMessage.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    z-index: 10000;
                    text-align: center;
                `;
                loadingMessage.innerHTML = `
                    <div>Generating PDF...</div>
                    <div style="margin-top: 10px; font-size: 12px;">This may take a few moments</div>
                `;
                document.body.appendChild(loadingMessage);

                try {
                    
                    // Create the temporary container
                    tempContainer = document.createElement('div');
                    tempContainer.style.cssText = `
                        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                        line-height: 1.6;
                        color: #333;
                        max-width: 800px;
                        margin: 0 auto;
                        padding: 40px;
                        background: white;
                        position: absolute;
                        left: -9999px;
                        top: 0;
                    `;

                    // Clone the editor content and clean it up for PDF
                    const clonedContent = editorContent.cloneNode(true);

                    // Remove any Quill-specific classes and attributes
                    const elementsToClean = clonedContent.querySelectorAll('*');
                    elementsToClean.forEach(el => {
                        // Remove Quill-specific classes
                        if (el.className) {
                            el.className = el.className.replace(/ql-[\w-]+/g, '').trim();
                            if (!el.className) {
                                el.removeAttribute('class');
                            }
                        }
                        // Remove contenteditable attributes
                        el.removeAttribute('contenteditable');
                        el.removeAttribute('spellcheck');
                    });

                    tempContainer.appendChild(clonedContent);
                    document.body.appendChild(tempContainer);

                    // Process images for better PDF compatibility
                    const images = tempContainer.querySelectorAll('img');
                    console.log(`Found ${images.length} images to process`);

                    // Preload all images to ensure they're ready for processing
                    const preloadImages = async () => {
                        const preloadPromises = Array.from(images).map((img, index) => {
                            return new Promise((resolve) => {
                                // Handle placeholder images
                                if (img.src.includes('placeholder.svg')) {
                                    console.log(`Preloading placeholder image ${index + 1}`);
                                    resolve();
                                    return;
                                }
                                
                                if (img.complete && img.naturalHeight > 0) {
                                    resolve();
                                } else {
                                    img.onload = resolve;
                                    img.onerror = resolve; // Continue even if image fails
                                    // Add timeout
                                    setTimeout(resolve, 5000);
                                }
                            });
                        });
                        await Promise.all(preloadPromises);
                        console.log('All images preloaded');
                    };
                    
                    await preloadImages();

                    // Function to convert image to blob and then to object URL
                    const convertImageToBlob = async (img) => {
                        try {
                            console.log(`Converting image to blob: ${img.src}`);
                            
                            // If image is already a blob URL, return it
                            if (img.src.startsWith('blob:')) {
                                return img.src;
                            }
                            
                            // If image is already base64, return it
                            if (img.src.startsWith('data:')) {
                                return img.src;
                            }
                            
                            let imageUrl = img.src;
                            
                            // Fetch the image as blob
                            const response = await fetch(imageUrl, {
                                mode: 'cors',
                                credentials: 'omit',
                                headers: {
                                    'Accept': 'image/*'
                                }
                            });
                            
                            if (!response.ok) {
                                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
                            }
                            
                            const contentType = response.headers.get('content-type');
                            if (!contentType || !contentType.startsWith('image/')) {
                                throw new Error(`Invalid content type: ${contentType}`);
                            }
                            
                            const blob = await response.blob();
                            
                            if (blob.size === 0) {
                                throw new Error('Empty blob received');
                            }
                            
                            // Create object URL from blob
                            const blobUrl = URL.createObjectURL(blob);
                            console.log(`Successfully converted image to blob URL (${blob.size} bytes)`);
                            
                            return blobUrl;
                            
                        } catch (error) {
                            console.warn(`Failed to convert image to blob:`, error);
                            
                            // Fallback: try canvas approach
                            try {
                                console.log('Trying canvas fallback...');
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Set canvas size to match image
                            canvas.width = img.naturalWidth || img.width;
                            canvas.height = img.naturalHeight || img.height;
                            
                            // Draw image to canvas
                                ctx.drawImage(img, 0, 0);
                                
                                // Convert canvas to blob
                                return new Promise((resolve, reject) => {
                                    canvas.toBlob((blob) => {
                                        if (blob) {
                                            const blobUrl = URL.createObjectURL(blob);
                                            console.log('Canvas fallback successful');
                                            resolve(blobUrl);
                                        } else {
                                            reject(new Error('Canvas to blob conversion failed'));
                                        }
                                    }, 'image/jpeg', 0.9);
                                });
                                
                            } catch (canvasError) {
                                console.warn('Canvas fallback also failed:', canvasError);
                                throw error; // Throw original error
                            }
                        }
                    };

                    // Process all images with improved handling
                    const imagePromises = Array.from(images).map(async (img, index) => {
                        console.log(`Processing image ${index + 1}/${images.length}: ${img.src}`);
                        
                        try {
                                                // Handle placeholder images differently
                    if (img.src.includes('placeholder.svg')) {
                        console.log(`Processing placeholder image ${index + 1}`);
                                // Create a styled placeholder that will render well in PDF
                                const placeholderDiv = document.createElement('div');
                                placeholderDiv.style.cssText = `
                                width: 300px;
                                height: 200px;
                                display: flex;
                                    flex-direction: column;
                                align-items: center;
                                justify-content: center;
                                    border: 2px dashed #ddd;
                                border-radius: 8px;
                                background-color: #f8f9fa;
                                color: #666;
                                font-size: 14px;
                                text-align: center;
                                margin: 20px auto;
                                    font-family: Arial, sans-serif;
                                `;
                                placeholderDiv.innerHTML = `
                                    <div style="font-size: 32px; margin-bottom: 8px;">üì∑</div>
                                    <div style="font-weight: bold; margin-bottom: 4px;">Image Placeholder</div>
                                    <div style="font-size: 12px;">Click to add image</div>
                                `;
                                
                                if (img.parentNode) {
                                    img.parentNode.replaceChild(placeholderDiv, img);
                                }
                                return; // Skip further processing for placeholders
                            }
                            
                            // For S3 images, try multiple approaches
                            if (img.src.includes('s3.amazonaws.com')) {
                                console.log(`Processing S3 image with multiple fallbacks: ${index + 1}`);
                                
                                try {
                                    // Ensure proper styling for PDF
                                    img.style.maxWidth = '100%';
                                    img.style.height = 'auto';
                                    img.style.display = 'block';
                                    img.style.margin = '20px auto';
                                    
                                    // First try: Backend proxy (if available) - This is working!
                                    if (backendAvailable) {
                                        try {
                                            console.log(`Trying backend proxy for S3 image ${index + 1}`);
                                            const proxyUrl = `/api/images/proxy?url=${encodeURIComponent(img.src)}`;
                                            
                                            const proxyResponse = await fetch(proxyUrl);
                                            if (proxyResponse.ok) {
                                                const blob = await proxyResponse.blob();
                                                if (blob.size > 0) {
                                                    const blobUrl = URL.createObjectURL(blob);
                                                    img.src = blobUrl;
                                                    console.log(`‚úÖ S3 image ${index + 1} loaded via backend proxy (${blob.size} bytes)`);
                                                    return; // Success, exit early
                                                } else {
                                                    console.log(`Backend proxy returned empty blob for image ${index + 1}`);
                                                }
                                            } else {
                                                console.log(`Backend proxy failed for image ${index + 1} (${proxyResponse.status}), trying direct load`);
                                            }
                                        } catch (proxyError) {
                                            console.log(`Backend proxy error for image ${index + 1}:`, proxyError);
                                        }
                                    }
                                    
                                    // Second try: Direct load with CORS
                                    img.crossOrigin = 'anonymous';
                                    // Add cache busting to force fresh CORS check
                                    const originalSrc = img.src;
                                    img.src = originalSrc + (originalSrc.includes('?') ? '&' : '?') + '_cb=' + Date.now();
                                    
                                    // Wait for image to load if not already loaded
                                    if (!img.complete || img.naturalHeight === 0) {
                                        await new Promise((resolve, reject) => {
                                            const timeout = setTimeout(() => {
                                                console.log(`Timeout waiting for S3 image ${index + 1}, trying canvas fallback`);
                                                resolve();
                                            }, 8000);
                                            
                                            img.onload = () => {
                                                clearTimeout(timeout);
                                                console.log(`S3 image ${index + 1} loaded directly with CORS`);
                                                resolve();
                                            };
                                            img.onerror = () => {
                                                clearTimeout(timeout);
                                                console.log(`S3 image ${index + 1} failed direct load, trying canvas fallback`);
                                                resolve(); // Don't reject, let it proceed
                                            };
                                        });
                                    }
                                    
                                    // Third try: Convert to blob using canvas if image loaded
                                    if (img.complete && img.naturalHeight > 0) {
                                        try {
                                            console.log(`Converting S3 image ${index + 1} to blob via canvas`);
                                            const canvas = document.createElement('canvas');
                                            const ctx = canvas.getContext('2d');
                                            
                                            canvas.width = img.naturalWidth;
                                            canvas.height = img.naturalHeight;
                                            
                                            ctx.drawImage(img, 0, 0);
                                            
                                            const blobUrl = await new Promise((resolve, reject) => {
                                                canvas.toBlob((blob) => {
                                                    if (blob) {
                                                        const url = URL.createObjectURL(blob);
                                                        console.log(`S3 image ${index + 1} converted to blob successfully`);
                                                        resolve(url);
                                                    } else {
                                                        reject(new Error('Canvas to blob conversion failed'));
                                                    }
                                                }, 'image/jpeg', 0.9);
                                            });
                                            
                                            img.src = blobUrl;
                                            console.log(`S3 image ${index + 1} now using blob URL`);
                                            
                                        } catch (canvasError) {
                                            console.warn(`Canvas conversion failed for S3 image ${index + 1}:`, canvasError);
                                            // Fourth try: Use fetch without CORS for public images
                                            try {
                                                console.log(`Trying fetch without CORS for S3 image ${index + 1}`);
                                                const response = await fetch(img.src, { mode: 'no-cors' });
                                                if (response.type === 'opaque') {
                                                    console.log(`S3 image ${index + 1} accessible without CORS`);
                                                    // Keep original image
                                                } else {
                                                    console.log(`S3 image ${index + 1} fetch without CORS failed`);
                                                }
                                            } catch (fetchError) {
                                                console.warn(`Fetch without CORS failed for S3 image ${index + 1}:`, fetchError);
                                            }
                                        }
                                    }
                                    
                                    return; // Keep processed S3 image
                                    
                                } catch (error) {
                                    console.warn(`Error processing S3 image ${index + 1}:`, error);
                                    // Will fall through to fallback creation
                                }
                            }
                            
                            // For other images, try blob conversion
                            console.log(`Attempting blob conversion for image ${index + 1}`);
                            
                            // Wait for image to load if not already loaded
                            if (!img.complete || img.naturalHeight === 0) {
                                await new Promise((resolve, reject) => {
                                    img.onload = resolve;
                                    img.onerror = reject;
                                    setTimeout(() => reject(new Error('Image load timeout')), 15000);
                                });
                            }
                            
                            // Convert to blob URL
                            const blobUrl = await convertImageToBlob(img);
                            img.src = blobUrl;
                            console.log(`Successfully converted image ${index + 1} to blob URL`);
                            
                        } catch (error) {
                            console.warn(`Failed to process image ${index + 1}:`, error);
                            
                            // Create a professional fallback for failed images
                            console.log(`Creating fallback for failed image ${index + 1}`);
                            const fallbackDiv = document.createElement('div');
                            fallbackDiv.style.cssText = `
                                width: 300px;
                                height: 200px;
                                display: flex;
                                flex-direction: column;
                                align-items: center;
                                justify-content: center;
                                border: 2px dashed #6c5ce7;
                                border-radius: 8px;
                                background-color: #f8f9fa;
                                color: #2d3436;
                                font-size: 14px;
                                text-align: center;
                                margin: 20px auto;
                                font-family: Arial, sans-serif;
                            `;
                            fallbackDiv.innerHTML = `
                                <div style="font-size: 32px; margin-bottom: 8px;">üñºÔ∏è</div>
                                <div style="font-weight: bold; margin-bottom: 4px;">Blog Image</div>
                                <div style="font-size: 12px; color: #636e72;">Content preserved in PDF</div>
                            `;
                            
                            if (img.parentNode) {
                            img.parentNode.replaceChild(fallbackDiv, img);
                            }
                            console.log(`Created fallback for image ${index + 1}`);
                        }
                    });

                    // Wait for all images to be processed with timeout
                    try {
                        const results = await Promise.allSettled(imagePromises);
                        const successful = results.filter(r => r.status === 'fulfilled').length;
                        const failed = results.filter(r => r.status === 'rejected').length;
                        console.log(`Image processing complete: ${successful} successful, ${failed} failed`);
                        
                        if (failed > 0) {
                            console.log('Failed images will show as placeholders in PDF');
                        }
                    } catch (error) {
                        console.warn('Error in image processing:', error);
                    }
                    
                    // Add a small delay to ensure all images and fallbacks are properly rendered
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    console.log('Starting PDF generation with processed images and fallbacks...');

                    // Generate PDF using html2canvas and jsPDF
                    const canvas = await html2canvas(tempContainer, {
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        letterRendering: true,
                        logging: false, // Reduced logging for cleaner console
                        imageTimeout: 30000, // Increased timeout
                        removeContainer: false,
                        foreignObjectRendering: false,
                        backgroundColor: '#ffffff',
                        width: tempContainer.offsetWidth,
                        height: tempContainer.offsetHeight,
                        onclone: function(clonedDoc) {
                            // Ensure all images are visible in cloned document
                            const imgs = clonedDoc.querySelectorAll('img');
                            imgs.forEach(img => {
                                img.style.display = 'block';
                                img.style.visibility = 'visible';
                                img.style.opacity = '1';
                                img.style.maxWidth = '100%';
                                img.style.height = 'auto';
                            });
                            
                            // Also ensure fallback divs are visible
                            const fallbacks = clonedDoc.querySelectorAll('div[style*="dashed"]');
                            fallbacks.forEach(div => {
                                div.style.display = 'flex';
                                div.style.visibility = 'visible';
                            });
                        },
                        ignoreElements: (element) => {
                            // Ignore elements that might cause issues
                            return element.classList.contains('ql-toolbar') || 
                                   element.classList.contains('ql-clipboard');
                        }
                    });

                    // Create PDF
                    const PDFConstructor = window.getjsPDFConstructor();
                    console.log('Using jsPDF constructor:', typeof PDFConstructor);
                    
                    const pdf = new PDFConstructor('p', 'mm', 'a4');
                    console.log('PDF instance created successfully');
                    
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 295; // A4 height in mm
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    // Add first page
                    pdf.addImage(canvas, 'JPEG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    // Add additional pages if needed
                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(canvas, 'JPEG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    // Save the PDF
                    pdf.save('blog-content.pdf');
                    console.log('PDF generated and downloaded successfully');

                } catch (error) {
                    console.error('Error generating PDF:', error);
                    showToast('Error generating PDF. Please try again.', 'error');
                } finally {
                    // Clean up
                    if (tempContainer && tempContainer.parentNode) {
                        // Clean up blob URLs to free memory
                        const blobImages = tempContainer.querySelectorAll('img[src^="blob:"]');
                        blobImages.forEach(img => {
                            URL.revokeObjectURL(img.src);
                            console.log('Cleaned up blob URL:', img.src);
                        });
                        
                        tempContainer.parentNode.removeChild(tempContainer);
                    }
                    if (loadingMessage && loadingMessage.parentNode) {
                        loadingMessage.parentNode.removeChild(loadingMessage);
                    }
                }
            });
        }
        

        
    // Process topic from URL parameters with a small delay to ensure page is loaded
    setTimeout(() => {
    const urlParams = new URLSearchParams(window.location.search);
        const topic = urlParams.get("topic");
    
        // Check if this is a page refresh or new navigation
        const isPageRefresh = window.performance.navigation.type === 1 || 
                             window.performance.getEntriesByType('navigation')[0]?.type === 'reload';
        
        // If there's a topic parameter, handle based on whether it's a refresh or new navigation
        if (topic && topic.trim() !== "") {
            const hasGenerated = localStorage.getItem(`blogGenerated_${topic}`);
            
            if (isPageRefresh && hasGenerated) {
                // This is a refresh of an already generated blog - don't regenerate
                console.log('üîÑ Page refresh detected for existing topic, skipping regeneration:', topic);
                
                // Load existing content if available
                const savedBlog = localStorage.getItem("BlogGenerated");
                if (savedBlog && savedBlog !== '<h2>Write a blog here or generate a blog using the chat section</h2>') {
                    quill.root.innerHTML = savedBlog;
                    console.log('‚úÖ Loaded existing blog content from localStorage');
                }
                
                // Load chat history if available
                const savedHistory = localStorage.getItem('chatHistory');
                if (savedHistory) {
                    loadChatHistory();
                    console.log('‚úÖ Loaded existing chat history from localStorage');
                }
                
                    } else {
                // This is a new topic or first time loading - generate fresh
                console.log('üÜï New topic detected, ensuring fresh start:', topic);
                
                // Clear all previous data for fresh start
                localStorage.removeItem("chatHistory");
                localStorage.removeItem("BlogGenerated");
                localStorage.removeItem("previousBlogContent");
                localStorage.removeItem("currentBlogId");
                localStorage.removeItem("generatedKeywords");
                localStorage.removeItem("top50Keywords");
                
                // Clear all topic generation flags
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('blogGenerated_')) {
                        localStorage.removeItem(key);
                    }
                });
                
                // Clear restoration flag for fresh start
                localStorage.removeItem("isRestoringChat");
                
                // Clear chat messages and add fresh welcome message
                const chatMessages = document.getElementById("chat-messages");
                if (chatMessages) {
                    chatMessages.innerHTML = '';
                    addMessageToChat(
                        `‚ú® Ready to create a blog about: "${topic}"! Let me generate that for you...`,
                        false
                    );
                }
                
                // Reset Quill editor to default state
                if (quill) {
                    quill.root.innerHTML = '<h2>Write a blog here or generate a blog using the chat section</h2>';
                }
                
                // Reset conversation state
        resetConversationState();
        
        // Set the topic in the textarea
          const chatInput = document.getElementById("user-input");
                if (chatInput) {
        chatInput.value = topic;
                }
        
        // Trigger the send button click event
          const sendButton = document.querySelector(".send-button");
        if (sendButton) {
            // Create and dispatch a click event
            const clickEvent = new Event("click");
            sendButton.dispatchEvent(clickEvent);
                } else {
                    console.error('‚ùå Send button not found');
        }
                
                console.log('‚úÖ Fresh start completed for new topic');
    }
        } else {
            console.log('üìù No topic parameter found in URL');
        }
    }, 500); // Small delay to ensure page is fully loaded

        const modal = document.getElementById("imageModal");
        const generateImageBtn = document.getElementById("generateImageBtn");
        const uploadImageBtn = document.getElementById("uploadImageBtn");
        const removeImageBtn = document.getElementById("removeImageBtn");
        const promptInputContainer = document.getElementById(
          "promptInputContainer"
        );
        const promptInput = document.getElementById("promptInput");
        const cancelPromptBtn = document.getElementById("cancelPromptBtn");
        const submitPromptBtn = document.getElementById("submitPromptBtn");
        const imageUploadInput = document.getElementById("imageUploadInput");

            // makeDraggable function is now defined globally - no need for local definition

        // Function to show modal
    function showModal(e) {
          const modal = document.getElementById("imageModal");
          const modalContent = modal.querySelector(".modal-content");
                const clickedImage = e.target;
                
                // Set modal content size
                modalContent.style.width = "300px";
          modalContent.style.minWidth = "300px";
          modalContent.style.maxWidth = "400px";
                
                // Position the modal content in center (using pixel values for draggability)
          modalContent.style.position = "fixed";
          const centerTop = (window.innerHeight - 400) / 2; // Approximate modal height
          const centerLeft = (window.innerWidth - 300) / 2;  // Modal width
          modalContent.style.top = centerTop + "px";
          modalContent.style.left = centerLeft + "px";
          modalContent.style.transform = "none"; // Remove transform to enable dragging
          modalContent.style.cursor = "default";
          modalContent.style.zIndex = "1002";
                
                // Show the modal (no full-screen overlay)
          modal.style.display = "block";
          modal.style.position = "fixed";
          modal.style.top = "0";
          modal.style.left = "0";
          modal.style.width = "0";
          modal.style.height = "0";
          modal.style.background = "transparent";
          modal.style.pointerEvents = "none"; // Allow clicking through overlay
          
          // Make the modal draggable
          makeDraggable(modalContent);
          modal.style.zIndex = "1001";
          
          // Ensure the modal is within viewport bounds
          setTimeout(() => {
              const rect = modalContent.getBoundingClientRect();
              if (rect.left < 0) modalContent.style.left = "10px";
              if (rect.top < 0) modalContent.style.top = "10px";
              if (rect.right > window.innerWidth) modalContent.style.left = (window.innerWidth - rect.width - 10) + "px";
              if (rect.bottom > window.innerHeight) modalContent.style.top = (window.innerHeight - rect.height - 10) + "px";
          }, 10);
                
        // Reset prompt input container visibility
          document.getElementById("promptInputContainer").style.display =
            "none";
    }

    // Function to hide modal
    function hideModal() {
          const modal = document.getElementById("imageModal");
          modal.style.display = "none";
        // Clear prompt input
          promptInput.value = "";
    }

            // Update the click event listener for images
        document
          .querySelector(".ql-editor")
          .addEventListener("click", function (e) {
            if (e.target.tagName === "IMG") {
            // Remove data-clicked attribute from all images
              document.querySelectorAll(".ql-editor img").forEach((img) => {
                img.removeAttribute("data-clicked");
            });
            // Add data-clicked attribute to the clicked image
              e.target.setAttribute("data-clicked", "true");
                    showModal(e);
        }
    });

    // Close modal when clicking outside
        modal.addEventListener("click", function (e) {
        if (e.target === modal) {
            hideModal();
        }
    });

    // Handle generate image button click
        generateImageBtn.addEventListener("click", function () {
          promptInputContainer.style.display = "block";
        promptInput.focus();
    });

    // Handle cancel prompt button click
        cancelPromptBtn.addEventListener("click", function () {
          promptInputContainer.style.display = "none";
          promptInput.value = "";
    });

    // Handle submit prompt button click
        submitPromptBtn.addEventListener("click", async function () {
        const prompt = promptInput.value.trim();
        if (prompt) {
            // Add loading state to the button
            submitPromptBtn.classList.add("loading");
            const originalText = submitPromptBtn.innerHTML;
            submitPromptBtn.innerHTML =
              '<span class="button-text">Generating...</span>';
            
            hideModal();
            // Show loading state
            addMessageToChat("Generating image based on your prompt...", false);
            
            try {
                const imageUrls = await generateImage(prompt);
                if (imageUrls && imageUrls.length > 0) {
                    // Get the clicked image (stored when modal was opened)
                const clickedImage = document.querySelector(
                  '.ql-editor img[data-clicked="true"]'
                );
                    if (clickedImage) {
                        // Replace the clicked image with the generated image
                        clickedImage.src = imageUrls[0];
                  clickedImage.style.opacity = "1";
                  clickedImage.removeAttribute("data-clicked");
                        
                        // Add the same hover effects to the new image
                  clickedImage.style.transition = "all 0.3s ease";
                  clickedImage.style.cursor = "pointer";
                    }
                } else {
                addMessageToChat(
                  "Sorry, there was an error generating the image.",
                  false
                );
                }
            } catch (error) {
              console.error("Error generating image:", error);
              addMessageToChat(
                "Sorry, there was an error generating the image.",
                false
              );
            } finally {
                // Remove loading state
              submitPromptBtn.classList.remove("loading");
                submitPromptBtn.innerHTML = originalText;
            }
        } else {
            // Show error state in input
            promptInput.style.borderColor = "#ff7675";
            setTimeout(() => {
              promptInput.style.borderColor = "#dfe6e9";
            }, 2000);
        }
    });

    // Handle upload image button click
        uploadImageBtn.addEventListener("click", function () {
        imageUploadInput.click();
    });

    // Handle file selection
        imageUploadInput.addEventListener("change", function (e) {
        const file = e.target.files[0];
        if (file) {
            // Check if file is an image
            if (!file.type.startsWith("image/")) {
                addMessageToChat("Please select an image file.", false);
                return;
            }

            // Create a FileReader to read the image
            const reader = new FileReader();
            reader.onload = function (e) {
                const imageUrl = e.target.result;
                // Get the clicked image
              const clickedImage = document.querySelector(
                '.ql-editor img[data-clicked="true"]'
              );
                if (clickedImage) {
                    // Replace the clicked image with the uploaded image
                    clickedImage.src = imageUrl;
                clickedImage.style.opacity = "1";
                    
                    // Add the same hover effects to the new image
                clickedImage.style.transition = "all 0.3s ease";
                clickedImage.style.cursor = "pointer";
                }
                hideModal();
            };
            reader.readAsDataURL(file);
        }
    });

    // Add drag and drop functionality for images
        const editor = document.querySelector(".ql-editor");
    
    // Make placeholder images draggable
        editor.addEventListener("dragstart", function (e) {
          if (
            e.target.tagName === "IMG" &&
            e.target.src.includes("placeholder.svg")
          ) {
            e.dataTransfer.setData("text/plain", "placeholder");
        }
    });

    // Handle drag over placeholder images
        editor.addEventListener("dragover", function (e) {
          if (
            e.target.tagName === "IMG" &&
            e.target.src.includes("placeholder.svg")
          ) {
            e.preventDefault();
            e.target.style.opacity = "0.5";
        }
    });

    // Handle drag leave
        editor.addEventListener("dragleave", function (e) {
          if (
            e.target.tagName === "IMG" &&
            e.target.src.includes("placeholder.svg")
          ) {
            e.target.style.opacity = "1";
        }
    });

    // Handle drop on placeholder images
        editor.addEventListener("drop", function (e) {
        e.preventDefault();
        const targetImg = e.target;
        
          if (
            targetImg.tagName === "IMG" &&
            targetImg.src.includes("placeholder.svg")
          ) {
            // Get the dragged image URL from the chat
            const draggedImg =
              document.querySelector(".chat-messages img:active") ||
              document.querySelector(".chat-messages img:hover");
            
            if (draggedImg) {
                // Replace placeholder with the dragged image
                targetImg.src = draggedImg.src;
              targetImg.style.opacity = "1";
                
                // Add the same hover effects to the new image
              targetImg.style.transition = "all 0.3s ease";
              targetImg.style.cursor = "pointer";
                
                // Add click event to the new image to show the modal
              targetImg.addEventListener("click", function (e) {
                            showModal(e);
                });
            }
        }
    });

    // Make chat images draggable
        document
          .querySelector(".chat-messages")
          .addEventListener("dragstart", function (e) {
            if (e.target.tagName === "IMG") {
              e.dataTransfer.setData("text/plain", "chat-image");
              e.dataTransfer.setData("image-url", e.target.src);
        }
    });

    // Add draggable attribute to chat images
        document.querySelectorAll(".chat-messages img").forEach((img) => {
        img.draggable = true;
    });

    // Handle remove image button click
        removeImageBtn.addEventListener("click", function () {
          const clickedImage = document.querySelector(
            '.ql-editor img[data-clicked="true"]'
          );
        if (clickedImage) {
            // Get the parent node
            const parent = clickedImage.parentNode;
            
            // Remove any empty text nodes or line breaks before the image
            let prevNode = clickedImage.previousSibling;
            while (
              prevNode &&
              (prevNode.nodeType === Node.TEXT_NODE ||
                prevNode.tagName === "BR") &&
              (!prevNode.textContent || prevNode.textContent.trim() === "")
            ) {
                const nodeToRemove = prevNode;
                prevNode = prevNode.previousSibling;
                parent.removeChild(nodeToRemove);
            }
            
            // Remove any empty text nodes or line breaks after the image
            let nextNode = clickedImage.nextSibling;
            while (
              nextNode &&
              (nextNode.nodeType === Node.TEXT_NODE ||
                nextNode.tagName === "BR") &&
              (!nextNode.textContent || nextNode.textContent.trim() === "")
            ) {
                const nodeToRemove = nextNode;
                nextNode = nextNode.nextSibling;
                parent.removeChild(nodeToRemove);
            }
            
            // Remove the image itself
            clickedImage.remove();
            
            // Update localStorage
            localStorage.setItem("BlogGenerated", quill.root.innerHTML);
            
            // Hide modal
            hideModal();
            
            // Show success message
            addMessageToChat("Image has been removed successfully.", false);
        }
    });
});

// Function to add a message to the chat
      async function addMessageToChat(
        message,
        isUser = false,
        imageUrls = null,
        isModification = false,
        previousContent = null,
        isLoading = false
      ) {
        const messagesContainer = document.getElementById("chat-messages");
        const messageDiv = document.createElement("div");
        messageDiv.className = "message-wrapper";
    
    let messageContent;
    if (imageUrls) {
          const imageElements = imageUrls
            .map(
              (url) =>
                `<img src="${url}" alt="Generated image" style="max-width: 200px; margin: 5px;">`
            )
            .join("");
        messageContent = `
            <div class="${isUser ? "user-avatar" : "ai-avatar"}${isLoading ? " loading" : ""}">${
            isUser ? "You" : "AI"
          }</div>
            <div class="message-meta">
                <div class="message ${isUser ? "user-message" : "ai-message"}">
                    <div class="message-content">
                        <p>${message}</p>
                        <div class="generated-images">${imageElements}</div>
                    </div>
                    <div class="message-time">Just now</div>
                </div>
            </div>
        `;
    } else {
        messageContent = `
            <div class="${isUser ? "user-avatar" : "ai-avatar"}${isLoading ? " loading" : ""}">${
            isUser ? "You" : "AI"
          }</div>
            <div class="message-meta">
                <div class="message ${isUser ? "user-message" : "ai-message"}">
                    <div class="message-content">
                        <p>${message}</p>
                    </div>
                    <div class="message-time">Just now</div>
                </div>
            </div>
        `;
    }
    
    messageDiv.innerHTML = messageContent;
    
    // Add restore button for modification messages (AI responses to user modifications)
    if (isModification && !isUser && previousContent) {
        const messageMeta = messageDiv.querySelector('.message-meta');
        const restoreButton = document.createElement('button');
        restoreButton.className = 'restore-button';
        restoreButton.innerHTML = '<i class="fas fa-undo"></i>';
        restoreButton.title = 'Restore previous version';
        restoreButton.onclick = () => restoreBlogContent(previousContent);
        messageMeta.appendChild(restoreButton);
    }
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Save the message to MongoDB and blog chat history
    try {
        await saveChatMessage(
            message, 
            isUser ? "user" : "bot",
            imageUrls ? { imageUrls } : {}
        );
    } catch (error) {
          console.error("Error saving chat message:", error);
    }
    
    // Save chat history to localStorage after adding message
    saveChatHistory();
}

// Function to restore blog content to a previous state
function restoreBlogContent(previousContent) {
    try {
        // Update the editor with the previous content
        quill.root.innerHTML = previousContent;
        
        // Update localStorage
        localStorage.setItem("BlogGenerated", previousContent);
        
        // Remove all restore buttons since we've restored to a previous state
        const restoreButtons = document.querySelectorAll('.restore-button');
        restoreButtons.forEach(button => {
            button.remove();
        });
        
        // Clear the previous content from localStorage since it's no longer needed
        localStorage.removeItem('previousBlogContent');
        
        // Add a notification message
        addMessageToChat("Blog content has been restored to the previous version.", false);
        
        console.log('‚úÖ Blog content restored successfully');
        console.log('üóëÔ∏è Removed', restoreButtons.length, 'restore buttons');
    } catch (error) {
        console.error('‚ùå Error restoring blog content:', error);
        addMessageToChat("Sorry, there was an error restoring the blog content.", false);
    }
}

// Function to save chat history to localStorage
function saveChatHistory() {
    try {
        const chatMessages = document.getElementById("chat-messages");
        const messages = [];
        
        // Get all message wrappers
        const messageWrappers = chatMessages.querySelectorAll('.message-wrapper');
        
        messageWrappers.forEach((wrapper, index) => {
            // Skip the first message (welcome message) if it's the default one
            if (index === 0) {
                const welcomeText = wrapper.textContent || '';
                if (welcomeText.includes('Welcome') || welcomeText.includes('Hello')) {
                    return; // Skip default welcome message
                }
            }
            
            const messageData = {
                content: wrapper.querySelector('.message-content p')?.textContent || '',
                isUser: wrapper.querySelector('.user-avatar') !== null,
                timestamp: wrapper.querySelector('.message-time')?.textContent || 'Just now',
                images: [],
                isModification: !wrapper.querySelector('.user-avatar') && isModificationMessage(wrapper.querySelector('.message-content p')?.textContent || '')
            };
            
            // Extract images if any
            const images = wrapper.querySelectorAll('.generated-images img');
            images.forEach(img => {
                messageData.images.push({
                    src: img.src,
                    alt: img.alt || 'Generated image'
                });
            });
            
            messages.push(messageData);
        });
        
        // Save to localStorage
        localStorage.setItem('chatHistory', JSON.stringify(messages));
        console.log('üíæ Chat history saved:', messages.length, 'messages');
        
    } catch (error) {
        console.error('Error saving chat history:', error);
    }
}

// Function to load chat history from localStorage
function loadChatHistory() {
    try {
        const chatMessages = document.getElementById("chat-messages");
    
    // Clear existing messages except the welcome message
    while (chatMessages.children.length > 1) {
        chatMessages.removeChild(chatMessages.lastChild);
    }
        
        // Load saved chat history
        const savedHistory = localStorage.getItem('chatHistory');
        if (savedHistory) {
            const messages = JSON.parse(savedHistory);
            console.log('üìÇ Loading chat history:', messages.length, 'messages');
            
            messages.forEach((messageData, index) => {
                // Recreate message elements
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message-wrapper';
                
                let messageContent = '';
                if (messageData.isUser) {
                    messageContent = `
                        <div class="user-avatar">You</div>
                        <div class="message-meta">
                            <div class="message user-message">
                                <div class="message-content">
                                    <p>${messageData.content}</p>
                                </div>
                                <div class="message-time">${messageData.timestamp}</div>
                            </div>
                        </div>
                    `;
                } else {
                    let imagesHTML = '';
                    if (messageData.images && messageData.images.length > 0) {
                        const imageElements = messageData.images
                            .map(img => `<img src="${img.src}" alt="${img.alt}" style="max-width: 200px; margin: 5px;">`)
                            .join('');
                        imagesHTML = `<div class="generated-images">${imageElements}</div>`;
                    }
                    
                    messageContent = `
                        <div class="ai-avatar">AI</div>
                        <div class="message-meta">
                            <div class="message ai-message">
                                <div class="message-content">
                                    <p>${messageData.content}</p>
                                    ${imagesHTML}
                                </div>
                                <div class="message-time">${messageData.timestamp}</div>
                            </div>
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = messageContent;
                
                // Add restore button for modification messages (AI responses that mention modifications)
                if (messageData.isModification) {
                    const messageMeta = messageDiv.querySelector('.message-meta');
                    if (messageMeta) {
                        const restoreButton = document.createElement('button');
                        restoreButton.className = 'restore-button';
                        restoreButton.innerHTML = '<i class="fas fa-undo"></i>';
                        restoreButton.title = 'Restore previous version';
                        restoreButton.onclick = () => {
                            // For historical messages, we'll need to get the previous content from localStorage
                            const previousContent = localStorage.getItem('previousBlogContent');
                            if (previousContent) {
                                restoreBlogContent(previousContent);
                            } else {
                                addMessageToChat("Sorry, the previous version is not available for this message.", false);
                            }
                        };
                        messageMeta.appendChild(restoreButton);
                    }
                }
                
                chatMessages.appendChild(messageDiv);
            });
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
            console.log('‚úÖ Chat history loaded successfully');
            
        } else {
            console.log('üìÇ No saved chat history found');
        }
        
    } catch (error) {
        console.error('Error loading chat history:', error);
    }
}

// Function to identify modification messages
function isModificationMessage(content) {
    const modificationKeywords = [
        'modified successfully',
        'changes have been applied',
        'blog has been updated',
        'modification request',
        'updated successfully',
        'changes applied'
    ];
    
    return modificationKeywords.some(keyword => 
        content.toLowerCase().includes(keyword.toLowerCase())
    );
}

// Debug function to test restore functionality
window.testRestoreFunctionality = function() {
    console.log('üß™ Testing restore functionality...');
    
    // Check if previous content is saved
    const previousContent = localStorage.getItem('previousBlogContent');
    if (previousContent) {
        console.log('‚úÖ Previous content found in localStorage');
        console.log('Content length:', previousContent.length);
        console.log('First 100 chars:', previousContent.substring(0, 100));
    } else {
        console.log('‚ùå No previous content found in localStorage');
    }
    
    // Check current content
    const currentContent = quill.root.innerHTML;
    console.log('üìù Current content length:', currentContent.length);
    
    // Check if there are any restore buttons in the chat
    const restoreButtons = document.querySelectorAll('.restore-button');
    console.log('üîò Restore buttons found:', restoreButtons.length);
    
    // Check modification messages
    const chatMessages = document.getElementById("chat-messages");
    const messageWrappers = chatMessages.querySelectorAll('.message-wrapper');
    let modificationCount = 0;
    
    messageWrappers.forEach((wrapper, index) => {
        const content = wrapper.querySelector('.message-content p')?.textContent || '';
        if (isModificationMessage(content)) {
            modificationCount++;
            console.log(`üìù Modification message ${modificationCount}:`, content.substring(0, 50) + '...');
        }
    });
    
    console.log('üìä Total modification messages:', modificationCount);
};

// Debug function to test fresh start functionality
window.testFreshStart = function() {
    console.log('üß™ Testing fresh start functionality...');
    
    // Check URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const topic = urlParams.get("topic");
    console.log('üìù Topic parameter:', topic);
    
    // Check localStorage state
    const chatHistory = localStorage.getItem('chatHistory');
    const blogGenerated = localStorage.getItem('BlogGenerated');
    const previousContent = localStorage.getItem('previousBlogContent');
    const currentBlogId = localStorage.getItem('currentBlogId');
    
    console.log('üíæ localStorage state:');
    console.log('- chatHistory:', chatHistory ? 'exists' : 'not found');
    console.log('- BlogGenerated:', blogGenerated ? 'exists' : 'not found');
    console.log('- previousBlogContent:', previousContent ? 'exists' : 'not found');
    console.log('- currentBlogId:', currentBlogId ? 'exists' : 'not found');
    
    // Check Quill editor state
    const editorContent = quill ? quill.root.innerHTML : 'Quill not available';
    console.log('üìù Editor content length:', editorContent.length);
    console.log('üìù Editor content preview:', editorContent.substring(0, 100));
    
    // Check chat messages
    const chatMessages = document.getElementById("chat-messages");
    const messageCount = chatMessages ? chatMessages.children.length : 0;
    console.log('üí¨ Chat messages count:', messageCount);
    
    // Check generation flags
    const generationFlags = Object.keys(localStorage).filter(key => key.startsWith('blogGenerated_'));
    console.log('üö© Generation flags:', generationFlags);
};

// Debug function to test text selection functionality
window.testTextSelection = function() {
    console.log('üß™ Testing text selection functionality...');
    
    // Check if Quill is available
    if (!quill) {
        console.log('‚ùå Quill editor not available');
        return;
    }
    
    // Check if Add to Chat button exists
    const addToChatButton = document.querySelector('.add-to-chat-button');
    if (addToChatButton) {
        console.log('‚úÖ Add to Chat button found');
        console.log('Button visibility:', addToChatButton.style.display);
        console.log('Button classes:', addToChatButton.className);
    } else {
        console.log('‚ùå Add to Chat button not found');
    }
    
    // Check current selection
    const selection = quill.getSelection();
    if (selection && selection.length > 0) {
        const selectedText = quill.getText(selection.index, selection.length);
        console.log('üìù Current selection:', selectedText);
        console.log('Selection length:', selection.length);
        console.log('Selection index:', selection.index);
    } else {
        console.log('üìù No text currently selected');
    }
    
    // Check chat input
    const chatInput = document.getElementById('user-input');
    if (chatInput) {
        console.log('üí¨ Chat input value:', chatInput.value);
        console.log('Chat input focused:', document.activeElement === chatInput);
    } else {
        console.log('‚ùå Chat input not found');
    }
    
    // Test manual button positioning
    if (addToChatButton) {
        console.log('üîß Testing button positioning...');
        addToChatButton.style.left = '100px';
        addToChatButton.style.top = '100px';
        addToChatButton.style.display = 'flex';
        addToChatButton.classList.add('show');
        
        setTimeout(() => {
            addToChatButton.classList.remove('show');
            setTimeout(() => {
                addToChatButton.style.display = 'none';
            }, 300);
        }, 2000);
    }
};

// Debug function to test restore buttons in historical messages
window.testHistoricalRestoreButtons = function() {
    console.log('üß™ Testing historical restore buttons...');
    
    // Check all restore buttons in the chat
    const restoreButtons = document.querySelectorAll('.restore-button');
    console.log('üîò Total restore buttons found:', restoreButtons.length);
    
    // Check modification messages
    const chatMessages = document.getElementById("chat-messages");
    const messageWrappers = chatMessages.querySelectorAll('.message-wrapper');
    let modificationCount = 0;
    let restoreButtonCount = 0;
    
    messageWrappers.forEach((wrapper, index) => {
        const content = wrapper.querySelector('.message-content p')?.textContent || '';
        const isUser = wrapper.querySelector('.user-avatar') !== null;
        const hasRestoreButton = wrapper.querySelector('.restore-button') !== null;
        
        if (!isUser && isModificationMessage(content)) {
            modificationCount++;
            console.log(`üìù Modification message ${modificationCount}:`, content.substring(0, 50) + '...');
            console.log(`   Has restore button: ${hasRestoreButton}`);
            
            if (hasRestoreButton) {
                restoreButtonCount++;
            }
        }
    });
    
    console.log('üìä Summary:');
    console.log('- Total modification messages:', modificationCount);
    console.log('- Messages with restore buttons:', restoreButtonCount);
    console.log('- Missing restore buttons:', modificationCount - restoreButtonCount);
    
    // Check localStorage for previous content
    const previousContent = localStorage.getItem('previousBlogContent');
    console.log('üíæ Previous content available:', !!previousContent);
    
    // Test adding restore buttons manually
    if (modificationCount > restoreButtonCount) {
        console.log('üîß Adding missing restore buttons...');
        messageWrappers.forEach((wrapper, index) => {
            const content = wrapper.querySelector('.message-content p')?.textContent || '';
            const isUser = wrapper.querySelector('.user-avatar') !== null;
            const hasRestoreButton = wrapper.querySelector('.restore-button') !== null;
            
            if (!isUser && isModificationMessage(content) && !hasRestoreButton) {
                const messageMeta = wrapper.querySelector('.message-meta');
                if (messageMeta) {
                    const restoreButton = document.createElement('button');
                    restoreButton.className = 'restore-button';
                    restoreButton.innerHTML = '<i class="fas fa-undo"></i>';
                    restoreButton.title = 'Restore previous version';
                    restoreButton.onclick = () => {
                        const previousContent = localStorage.getItem('previousBlogContent');
                        if (previousContent) {
                            restoreBlogContent(previousContent);
                        } else {
                            addMessageToChat("Sorry, the previous version is not available for this message.", false);
                        }
                    };
                    messageMeta.appendChild(restoreButton);
                    console.log(`‚úÖ Added restore button to message ${index + 1}`);
                }
            }
        });
    }
};

// Debug function to test refresh prevention
window.testRefreshPrevention = function() {
    console.log('üß™ Testing refresh prevention...');
    
    // Check URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const topic = urlParams.get("topic");
    console.log('üìù Topic parameter:', topic);
    
    // Check if this is a page refresh
    const isPageRefresh = window.performance.navigation.type === 1 || 
                         window.performance.getEntriesByType('navigation')[0]?.type === 'reload';
    console.log('üîÑ Is page refresh:', isPageRefresh);
    
    // Check generation flag
    const hasGenerated = topic ? localStorage.getItem(`blogGenerated_${topic}`) : null;
    console.log('üö© Generation flag exists:', !!hasGenerated);
    
    // Check localStorage state
    const chatHistory = localStorage.getItem('chatHistory');
    const blogGenerated = localStorage.getItem('BlogGenerated');
    const previousContent = localStorage.getItem('previousBlogContent');
    const currentBlogId = localStorage.getItem('currentBlogId');
    
    console.log('üíæ localStorage state:');
    console.log('- chatHistory:', chatHistory ? 'exists' : 'not found');
    console.log('- BlogGenerated:', blogGenerated ? 'exists' : 'not found');
    console.log('- previousBlogContent:', previousContent ? 'exists' : 'not found');
    console.log('- currentBlogId:', currentBlogId ? 'exists' : 'not found');
    
    // Check Quill editor state
    const editorContent = quill ? quill.root.innerHTML : 'Quill not available';
    console.log('üìù Editor content length:', editorContent.length);
    console.log('üìù Editor content preview:', editorContent.substring(0, 100));
    
    // Check chat messages
    const chatMessages = document.getElementById("chat-messages");
    const messageCount = chatMessages ? chatMessages.children.length : 0;
    console.log('üí¨ Chat messages count:', messageCount);
    
    // Check generation flags
    const generationFlags = Object.keys(localStorage).filter(key => key.startsWith('blogGenerated_'));
    console.log('üö© All generation flags:', generationFlags);
    
    // Test manual flag setting
    if (topic && !hasGenerated) {
        console.log('üîß Setting generation flag manually for testing...');
        localStorage.setItem(`blogGenerated_${topic}`, "true");
        console.log('‚úÖ Generation flag set manually');
    }
};

// Function to clean up the response content
function cleanResponseContent(content) {
    // Remove extra spaces and normalize line breaks
        let cleaned = content.replace(/\s+/g, " ").trim();
    
    // Replace markdown headers with HTML headers
        cleaned = cleaned.replace(/^#\s+(.+)$/gm, "<h1>$1</h1>");
        cleaned = cleaned.replace(/^##\s+(.+)$/gm, "<h2>$1</h2>");
        cleaned = cleaned.replace(/^###\s+(.+)$/gm, "<h3>$1</h3>");
        cleaned = cleaned.replace(/^####\s+(.+)$/gm, "<h4>$1</h4>");
        
        // Remove markdown code blocks
        cleaned = cleaned.replace(/```html\s*/gi, "");
        cleaned = cleaned.replace(/```\s*/g, "");
    
    // Replace markdown bold and italic with HTML
        cleaned = cleaned.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        cleaned = cleaned.replace(/\*(.+?)\*/g, "<em>$1</em>");
    
    // Replace markdown lists with HTML lists
        cleaned = cleaned.replace(/^\s*[-*+]\s+(.+)$/gm, "<li>$1</li>");
        cleaned = cleaned.replace(/(<li>.*<\/li>)/gs, "<ul>$1</ul>");
    
    // Replace markdown links with HTML links
        cleaned = cleaned.replace(
          /\[([^\]]+)\]\(([^)]+)\)/g,
          '<a href="$2">$1</a>'
        );
    
    // Add proper paragraph tags
        cleaned = cleaned.replace(/\n\n/g, "</p><p>");
        cleaned = "<p>" + cleaned + "</p>";
    
    // Clean up any double paragraph tags
        cleaned = cleaned.replace(/<\/p><p>/g, "</p><p>");

    // Center the placeholder images and add class for hover effects
        cleaned = cleaned.replace(
          /<img[^>]*src="[^"]*placeholder\.svg"[^>]*>/g,
          '<img src="./assets/placeholder.svg" style="display: block; margin: 2em auto; max-width: 100%; height: auto;" class="placeholder-image">'
        );
    
    return cleaned;
}

// Function to generate content from Gemini API via backend
async function generateContent(prompt) {
    try {
        // Create new AbortController for this generation
        generationController = new AbortController();
        const signal = generationController.signal;
        
        // Get authentication token
        const token = localStorage.getItem("token");
        if (!token) {
            throw new Error("Authentication token not found. Please log in again.");
        }
        
        console.log("Generating content with Gemini API via backend...");
        
        // Implement retry logic for backend API
        let retries = 0;
        const maxRetries = 3;
        let lastError = null;
        
        while (retries < maxRetries) {
            try {
                // Check if operation was aborted
                if (signal && signal.aborted) {
                    return null;
                }
                
                // Get top 50 keywords from localStorage if available
                let top50Keywords = [];
                try {
                    const storedKeywords = localStorage.getItem('top50Keywords');
                    if (storedKeywords) {
                        top50Keywords = JSON.parse(storedKeywords);
                    }
                } catch (error) {
                    console.error('Error parsing stored keywords:', error);
                }

                const response = await fetch(`${API_URL}/blogs/generate`, { 
                    method: 'POST',
                    signal,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ 
                        prompt,
                        keywords: top50Keywords
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Backend API responded with status ${response.status}: ${errorText}`);
                    
                    // Handle authentication errors
                    if (response.status === 401) {
                        localStorage.removeItem("token");
                        throw new Error("Authentication failed. Please log in again.");
                    }
                    
                    throw new Error(`API error: ${response.status} - ${errorText || 'No error details'}`);
                }
                
                const data = await response.json();
                if (!data || !data.success || !data.content) {
                    throw new Error("Invalid response format from API");
                }
                
                const cleanedContent = cleanResponseContent(data.content);
                return cleanedContent;
                
            } catch (fetchError) {
                lastError = fetchError;
                retries++;
                
                // If operation was aborted, don't retry
                if (fetchError.name === "AbortError") {
                    return null;
                }
                
                console.error(`Attempt ${retries}/${maxRetries} failed:`, fetchError);
                
                if (retries >= maxRetries) {
                    break;
                }
                
                // Wait before retrying (exponential backoff)
                const delay = Math.min(1000 * Math.pow(2, retries), 10000);
                console.log(`Retrying in ${delay}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        
        // If we've exhausted all retries, throw the last error
        console.error("All retry attempts failed:", lastError);
        throw new Error(`Failed to generate content after ${maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);

    } catch (error) {
        if (error.name === "AbortError") {
            return null;
        }
        console.error("Error generating content:", error);
        return `Sorry, there was an error generating the content: ${error.message}`;
    } finally {
        generationController = null;
    }
}

// Function to check and validate authentication token
function checkAuthToken() {
        const token = localStorage.getItem("token");
        
            console.log('üîç Checking auth token...');
            console.log('Token exists:', !!token);
    
    if (!token) {
          console.error("‚ùå No authentication token found");
          return {
            valid: false,
            error: "Authentication required. Please log in again.",
          };
    }
            
            console.log('Token preview:', token.substring(0, 50) + '...');
    
    // Basic JWT format validation
        if (!token.includes(".") || token.split(".").length !== 3) {
          console.error(
            "‚ùå Invalid token format:",
            token.substring(0, 20) + "..."
          );
          localStorage.removeItem("token"); // Remove invalid token
          return {
            valid: false,
            error: "Invalid authentication token. Please log in again.",
          };
    }
    
    // Check if token is expired (basic check)
    try {
          const payload = JSON.parse(atob(token.split(".")[1]));
        const currentTime = Math.floor(Date.now() / 1000);
                
                console.log('Token payload:', payload);
                console.log('Token expires:', payload.exp ? new Date(payload.exp * 1000) : 'No expiration');
                console.log('Current time:', new Date(currentTime * 1000));
        
        if (payload.exp && payload.exp < currentTime) {
            console.error("‚ùå Token expired:", new Date(payload.exp * 1000));
            localStorage.removeItem("token"); // Remove expired token
            return {
              valid: false,
              error: "Authentication token expired. Please log in again.",
            };
        }
    } catch (error) {
          console.error("‚ùå Error parsing token:", error);
          localStorage.removeItem("token"); // Remove invalid token
          return {
            valid: false,
            error: "Invalid authentication token. Please log in again.",
          };
    }
    
            console.log('‚úÖ Token is valid');
    return { valid: true, token };
}

// Function to modify content using analysis results
      async function modifyContentWithAnalysis(
        fullBlogContent,
        analysisResult,
        userRequest
      ) {
        try {
        // Create new AbortController for this modification
        generationController = new AbortController();
        const signal = generationController.signal;
        
        // Get keywords if available
          let keywords = "";
          try {
            const top50Keywords = JSON.parse(
              localStorage.getItem("top50Keywords") || "[]"
            );
            keywords = top50Keywords.map((k) => k.keyword).join(", ");
        } catch (error) {
            console.error("Error parsing keywords:", error);
        }
        
        // Check authentication token
        const authCheck = checkAuthToken();
        if (!authCheck.valid) {
            throw new Error(authCheck.error);
        }
        const token = authCheck.token;
        
        // Get current blog ID if available
          const currentBlogId = localStorage.getItem("currentBlogId");
        
        const response = await fetch(`${API_URL}/content/analyze`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({
                existingContent: fullBlogContent,
                modificationRequest: userRequest,
            }),
            signal,
        });
        
        if (!response.ok) {
          console.log(response)
            const errorData = await response.json();
            
            // Handle authentication errors specifically
            if (response.status === 401) {
              console.error("‚ùå Authentication failed:", errorData);
              localStorage.removeItem("token"); // Remove invalid token
              throw new Error("Authentication failed. Please log in again.");
            }

            throw new Error(errorData.message || "Failed to modify content");
        }
        
        const data = await response.json();
        console.log("Data:", data);
        
        if (!data.success || !data.modifiedContent) {
            throw new Error("No modified content received");
        }
        
        // Log modification details if available
        if (data.modificationDetails) {
            // Could be used for user feedback or analytics
        }
        
        const cleanedContent = cleanResponseContent(data.updatedBlogContent);
        return cleanedContent;
    } catch (error) {
          if (error.name === "AbortError") {
            return null;
        }
        console.error("‚ùå Error calling /content/modify:", error);
        return `Sorry, there was an error modifying the content: ${error.message}`;
    } finally {
        generationController = null;
    }
}

// Legacy function for backward compatibility
async function modifyContent(modificationRequest) {
    // This function is kept for backward compatibility
    // The new two-step process uses analyzeBlogModification and modifyContentWithAnalysis
    const existingContent = quill.root.innerHTML;
    
    // First analyze
        const analysis = await analyzeBlogModification(
          existingContent,
          modificationRequest
        );
    if (!analysis || !analysis.success) {
        return "Failed to analyze modification request";
    }
    
    // Then modify
        return await modifyContentWithAnalysis(
          existingContent,
          analysis.analysis,
          modificationRequest
        );
      }

      // Function to extract images from HTML content
      function extractImagesFromContent(content) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        const images = tempDiv.querySelectorAll('img');
        const imageData = [];
        
        images.forEach((img, index) => {
          imageData.push({
            src: img.src,
            alt: img.alt || `Image ${index + 1}`,
            className: img.className,
            style: img.getAttribute('style') || '',
            index: index
          });
        });
        
        return imageData;
      }

      // Function to preserve images in modified content
      function preserveImagesInContent(originalContent, modifiedContent) {
        const originalImages = extractImagesFromContent(originalContent);
        const modifiedImages = extractImagesFromContent(modifiedContent);
        
        // If there are images in the original content but not in modified content
        if (originalImages.length > 0 && modifiedImages.length === 0) {
          console.log('üñºÔ∏è Preserving images from original content');
          
          // Create a temporary div to work with the modified content
          const tempDiv = document.createElement('div');
          tempDiv.innerHTML = modifiedContent;
          
          // Find all headings and paragraphs to insert images at appropriate positions
          const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');
          const paragraphs = tempDiv.querySelectorAll('p');
          
          // Insert images after headings or paragraphs
          originalImages.forEach((imageData, index) => {
            const imgElement = document.createElement('img');
            imgElement.src = imageData.src;
            imgElement.alt = imageData.alt;
            imgElement.className = imageData.className;
            imgElement.setAttribute('style', imageData.style);
            
            // Insert image after heading if available, otherwise after paragraph
            if (headings[index]) {
              headings[index].parentNode.insertBefore(imgElement, headings[index].nextSibling);
            } else if (paragraphs[index]) {
              paragraphs[index].parentNode.insertBefore(imgElement, paragraphs[index].nextSibling);
            } else {
              // Insert at the end if no suitable position found
              tempDiv.appendChild(imgElement);
            }
          });
          
          return tempDiv.innerHTML;
        }
        
        return modifiedContent;
      }

      // Handle blog modifications for subsequent prompts
      async function handleBlogModification(message) {
        try {
          console.log("message", message);
          
          // Store the current content before modification
          const previousContent = quill.root.innerHTML;
          // Save previous content to localStorage for restore functionality
          localStorage.setItem('previousBlogContent', previousContent);
          
          // Show loading message with loading animation
          addMessageToChat("Processing your blog modification request...", false, null, false, null, true);
          
          // Get current blog content
          const existingContent = quill.root.innerHTML;
          console.log("existingContent", existingContent);
          
          // Check if user wants to change the entire blog
          const fullBlogChangeKeywords = [
            'change the entire blog', 'rewrite the entire blog', 'rewrite the whole blog',
            'change the whole blog', 'modify the entire blog', 'modify the whole blog',
            'rewrite everything', 'change everything', 'complete rewrite',
            'rewrite the blog completely', 'change the blog completely',
            'new version of the blog', 'completely new blog', 'entirely new blog'
          ];
          
          const isFullBlogChange = fullBlogChangeKeywords.some(keyword => 
            message.toLowerCase().includes(keyword.toLowerCase())
          );
          
          console.log('üîç Full blog change detected:', isFullBlogChange);
          
          // Create a simple analysis structure for modification
          const modificationAnalysis = {
            type: "blog_modification",
            instructions: message,
            sections: ["content", "structure"],
            focus: "user_request",
            preserveImages: isFullBlogChange
          };
          
          // Use the existing modifyContentWithAnalysis function
          const modifiedContent = await modifyContentWithAnalysis(
            existingContent,
            modificationAnalysis,
            message
          );
          
          if (modifiedContent && modifiedContent !== "Failed to analyze modification request") {
            // Preserve images if this is a full blog change
            let finalContent = modifiedContent;
            if (isFullBlogChange) {
              finalContent = preserveImagesInContent(existingContent, modifiedContent);
              console.log('üñºÔ∏è Images preserved in modified content');
            }
            
            // Update the editor with modified content
            quill.root.innerHTML = finalContent;
            
            // Update localStorage
            localStorage.setItem("BlogGenerated", finalContent);
            
            // Remove loading animation and show success message
            const loadingMessage = document.querySelector('.ai-avatar.loading');
            if (loadingMessage) {
              loadingMessage.classList.remove('loading');
            }
            
            // Add success message with restore functionality
            const successMessage = isFullBlogChange 
              ? "Blog has been completely rewritten while preserving your images! Your changes have been applied."
              : "Blog has been modified successfully! Your changes have been applied.";
            addMessageToChat(successMessage, false, null, true, previousContent);
          } else {
            // Remove loading animation and show error message
            const loadingMessage = document.querySelector('.ai-avatar.loading');
            if (loadingMessage) {
              loadingMessage.classList.remove('loading');
            }
            addMessageToChat("Sorry, I couldn't process that modification request. Please try being more specific about what you'd like to change.", false);
          }
        } catch (error) {
          console.error("Error in handleBlogModification:", error);
          // Remove loading animation and show error message
          const loadingMessage = document.querySelector('.ai-avatar.loading');
          if (loadingMessage) {
            loadingMessage.classList.remove('loading');
          }
          addMessageToChat("Sorry, there was an error processing your blog modification request. Please try again.", false);
        }
}

// Function to upload image to Cloudinary
async function uploadToCloudinary(base64Image) {
    try {
        // Convert base64 to blob
        const response = await fetch(base64Image);
        const blob = await response.blob();

        // Create form data
        const formData = new FormData();
          formData.append("file", blob);
          formData.append("upload_preset", "ml_default");

        // Upload to Cloudinary
          const uploadResponse = await fetch(
            `https://api.cloudinary.com/v1_1/dd3nlw5ub/image/upload`,
            {
              method: "POST",
              body: formData,
            }
          );

        if (!uploadResponse.ok) {
            throw new Error("Failed to upload to Cloudinary");
        }

        const data = await uploadResponse.json();
        return data.secure_url;
    } catch (error) {
          console.error("Error uploading to Cloudinary:", error);
        return null;
    }
}

// Function to replace placeholder images with actual images
function replaceImagePlaceholders(imageUrl) {
        const placeholderImages =
          document.querySelectorAll(".placeholder-image");
    if (placeholderImages.length > 0) {
        // Get the first placeholder image
        const placeholder = placeholderImages[0];
        
        // Create new image element
          const newImage = document.createElement("img");
        newImage.src = imageUrl;
          newImage.classList.add("blog-image");
          newImage.style.maxWidth = "100%";
          newImage.style.height = "auto";
          newImage.style.borderRadius = "8px";
          newImage.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
          newImage.style.margin = "2em 2em";
          newImage.style.transition = "transform 0.3s ease";
          newImage.style.width = "300px";
          newImage.style.cursor = "pointer";
        // Add hover effect
          newImage.addEventListener("mouseover", () => {
            newImage.style.transform = "scale(1.02)";
        });
          newImage.addEventListener("mouseout", () => {
            newImage.style.transform = "scale(1)";
        });
        
        // Replace placeholder with new image
        placeholder.parentNode.replaceChild(newImage, placeholder);
        
        // Update the editor content in localStorage
        const editorContent = quill.root.innerHTML;
          localStorage.setItem("BlogGenerated", editorContent);
        
        return true;
    }
    return false;
}

// Modify the generateImage function to include Cloudinary upload
async function generateImage(prompt) {
    try {
        // Enhance the prompt for better image generation
          const enhancedPrompt = `
          Create a high-quality, professional blog image: ${prompt}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post.
          `;

          const imageResponse = await fetch(
            "https://api.deepinfra.com/v1/openai/images/generations",
            {
              method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ofZxkV2E7aTDvbirZCB16zJHSbbfOxdN`,
            },
            body: JSON.stringify({
                prompt: enhancedPrompt,
                size: "1024x1024",
                model: "black-forest-labs/FLUX-1-dev",
                n: 1,
                guidance_scale: 20,
                num_inference_steps: 50,
                seed: 42,
                response_format: "b64_json",
                negative_prompt:
                  "blurry, low quality, distorted, text, watermark, signature, ugly, deformed, disfigured, poorly drawn face, mutation, mutated, extra limb, missing limb, floating limbs, disconnected limbs, malformed hands, blur, out of focus, long neck, long body, distorted proportions, bad anatomy, bad proportions, gross proportions, text, error, missing fingers, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry",
              }),
            }
          );

        if (!imageResponse.ok) {
            throw new Error("Image generation failed");
        }

        const imageData = await imageResponse.json();
        
        if (!imageData.data || imageData.data.length === 0) {
            throw new Error("No image data received");
        }

        // Convert base64 to image URL and upload to AWS S3
        const base64Image = `data:image/png;base64,${imageData.data[0].b64_json}`;
        const imageUrl = await uploadToAWS(base64Image);
        
        if (imageUrl) {
            replaceImagePlaceholders(imageUrl);
        }
        
        return [imageUrl];
    } catch (error) {
          console.error("Error generating image:", error);
          addMessageToChat(
            "Sorry, there was an error generating the image. Please try again.",
            false
          );
        return null;
    }
}

async function uploadToAWS(base64Image) {
    try {
        // Remove the data:image/png;base64, prefix
          const base64Data = base64Image.replace(
            /^data:image\/\w+;base64,/,
            ""
          );
        
        // Convert base64 to blob
        const byteCharacters = atob(base64Data);
        const byteArrays = [];
        
        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
            const slice = byteCharacters.slice(offset, offset + 512);
            const byteNumbers = new Array(slice.length);
            
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        
          const blob = new Blob(byteArrays, { type: "image/png" });
        
        // Create FormData and append the file
        const formData = new FormData();
          formData.append("image", blob, "image.png");
        
        // Get the token from localStorage
          const token = localStorage.getItem("token");
        
        // Send the image to your backend
          const response = await fetch(
            "http://localhost:5000/api/images/upload",
            {
              method: "POST",
            headers: {
                Authorization: `Bearer ${token}`,
            },
              body: formData,
            }
          );
        
        if (!response.ok) {
            throw new Error("Failed to upload image");
        }
        
        const data = await response.json();
        return data.data.imageUrl;
    } catch (error) {
          console.error("Error uploading image:", error);
          addMessageToChat(
            "Sorry, there was an error uploading the image. Please try again.",
            false
          );
        return null;
    }
}

// Function to update editor content
function updateEditorContent(content) {
    quill.root.innerHTML = content;
    
    // Set generation flag when content is successfully updated
    const urlParams = new URLSearchParams(window.location.search);
    const topic = urlParams.get("topic");
    if (topic && topic.trim() !== "") {
        localStorage.setItem(`blogGenerated_${topic}`, "true");
        console.log('‚úÖ Generation flag set for topic:', topic);
    }
}

// Main chat message handler
async function handleSendMessage(event) {
    if (event) {
        event.preventDefault();
    }
    
        const chatInput = document.getElementById("user-input");
    const message = chatInput.value.trim();
    
    console.log('üìù Input value before clearing:', message);
    
    if (!message) return;
    
    // Clear input immediately at the start
        chatInput.value = "";
    console.log('üßπ Input cleared, new value:', chatInput.value);
    
    // Force the input to update visually
    chatInput.dispatchEvent(new Event('input', { bubbles: true }));
    
    try {
        // Add and save user message
        await addMessageToChat(message, true);
    
        // Mark conversation as started
        conversationStarted = true;
    
        // CRITICAL FLOW CONTROL:
        if (isFirstPrompt) {
            // FIRST PROMPT: Generate complete blog
            
            await handleFirstPrompt(message);
            // Mark that first prompt is done
            isFirstPrompt = false;
            window.isFirstPrompt = false;
        } else {
            // SUBSEQUENT PROMPTS: Handle blog modifications
            await handleBlogModification(message);
        }
    } catch (error) {
          console.error("Error in handleSendMessage:", error);
          addMessageToChat(
            "Sorry, there was an error processing your request.",
            false
          );
    }
}

// Handle first prompt - complete blog generation flow
async function handleFirstPrompt(message) {
    try {
          await addMessageToChat(
            "Let me analyze and refine your topic to get the most relevant keywords...",
            false
          );
        
            // Show keyword loading animation and hide chat input only on mobile
          const keywordLoadingOverlay = document.getElementById(
            "keyword-loading-overlay"
          );
          const chatInputContainer = document.querySelector(
            ".chat-input-container"
          );
          keywordLoadingOverlay.style.display = "flex";
            if (window.innerWidth <= 426) {
            chatInputContainer.style.display = "none";
            }
            keywordAnimation.play();

            // Close chat on mobile devices after sending message
            if (window.innerWidth <= 426) {
            const chatSection = document.getElementById("chat-section");
            const mobileChatToggle =
              document.getElementById("mobile-chat-toggle");

            chatSection.classList.remove("visible");
            chatSection.style.display = "none";
            mobileChatToggle.classList.remove("chat-visible");
            mobileChatToggle.classList.add("chat-hidden");
                mobileChatToggle.innerHTML = '<i class="fa-solid fa-comments"></i>';
            }

            // Refine the prompt using backend Gemini API
            const token = localStorage.getItem("token");
            if (!token) {
                throw new Error("Authentication token not found");
            }

            const refinementResponse = await fetch(`${API_URL}/blogs/refine-keywords`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({ prompt: message })
            });
            
            if (!refinementResponse.ok) {
                throw new Error(`HTTP error! status: ${refinementResponse.status}`);
            }

            const refinementData = await refinementResponse.json();
            if (!refinementData.success || !refinementData.keywords) {
                throw new Error("Invalid response from keyword refinement API");
            }
            
            const refinedPrompt = refinementData.keywords.trim();
            
            // Split by newlines or commas and clean up each keyword
            const seedKeywords = refinedPrompt
                .split(/[\n,]+/)
            .map((keyword) => keyword.trim())
            .filter((keyword) => keyword.includes(" ")); // Ensure each keyword has at least two words
            
            // Array to store all generated keywords
            let allGeneratedKeywords = [];
            
            // Generate keywords for each seed word
            for (const seedWord of seedKeywords) {
                const options = {
              method: "GET",
                    headers: {
                "X-RapidAPI-Key":
                  "9f86168378mshcc0a7c32818d149p12ff05jsnf6e51b7bfdbf",
                "X-RapidAPI-Host": "seo-keyword-research-api.p.rapidapi.com",
              },
                };

                // URL encode each seed word for the API call
                const encodedQuery = encodeURIComponent(seedWord);
                const url = `https://seo-keyword-research-api.p.rapidapi.com/keyword-research?keyword=${encodedQuery}&country=us`;
                
                let retryCount = 0;
                const maxRetries = 3;
                let success = false;
                
                while (retryCount < maxRetries && !success) {
                    try {
                        const response = await fetch(url, options);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        
                        // Check if we got the specific RPC error
                if (data.error && data.error.includes("_InactiveRpcError")) {
                            retryCount++;
                            // Add a small delay before retrying
                  await new Promise((resolve) => setTimeout(resolve, 1000));
                            continue;
                        }

                        // Process the successful response
                        let keywordData = [];
                        if (data.result && Array.isArray(data.result)) {
                            keywordData = data.result;
                        } else if (Array.isArray(data)) {
                            keywordData = data;
                        } else if (data.data && Array.isArray(data.data)) {
                            keywordData = data.data;
                        } else if (data.keywords && Array.isArray(data.keywords)) {
                            keywordData = data.keywords;
                } else if (
                  data.suggestions &&
                  Array.isArray(data.suggestions)
                ) {
                            keywordData = data.suggestions;
                        }

                        // Extract and format keywords for this seed word
                        const keywords = keywordData
                  .map((item) => {
                                // Extract both keyword and avg_monthly_searches
                    const keyword =
                      item.keyword ||
                      item.term ||
                      item.suggestion ||
                      item.text ||
                      item.query ||
                      item.word ||
                      null;
                                const avg_monthly_searches = parseInt(
                                    item.avg_monthly_searches ||
                                    item.volume ||
                                    item.search_volume ||
                                    item.monthly_searches ||
                                    "0"
                                );
                                
                                if (keyword) {
                                    return {
                                        keyword: keyword,
                        avg_monthly_searches: avg_monthly_searches,
                                    };
                                }
                                return null;
                            })
                            .filter(Boolean); // Remove any null values

                        // Add these keywords to our main array
                        allGeneratedKeywords = [...allGeneratedKeywords, ...keywords];

                        // Log the keywords found for this seed word
                        
                        success = true; // Mark as successful to exit the retry loop
                    } catch (error) {
                console.error(
                  `Error fetching keywords for "${seedWord}":`,
                  error
                );
                        if (retryCount === maxRetries - 1) {
                            console.error(`Max retries reached for "${seedWord}"`);
                            throw error; // Re-throw the error after max retries
                        }
                        retryCount++;
                        // Add a small delay before retrying
                await new Promise((resolve) => setTimeout(resolve, 1000));
                    }
                }
            }

            // Remove duplicates by keyword and keep the highest avg_monthly_searches
            const uniqueKeywords = Object.values(
                allGeneratedKeywords.reduce((acc, curr) => {
              if (
                !acc[curr.keyword] ||
                acc[curr.keyword].avg_monthly_searches <
                  curr.avg_monthly_searches
              ) {
                        acc[curr.keyword] = curr;
                    }
                    return acc;
                }, {})
            );

            // Sort by length of keyword
            uniqueKeywords.sort((a, b) => a.keyword.length - b.keyword.length);

            // Display the keywords in the chat
            if (uniqueKeywords.length > 0) {
                const totalKeywords = uniqueKeywords.length;
                
                // Store the keywords in localStorage for later use
            localStorage.setItem(
              "generatedKeywords",
              JSON.stringify(uniqueKeywords)
            );
                
                // Get and store top 50 keywords immediately
                const top50 = getTopKeywords();
                
            await addMessageToChat(
              `Generated ${totalKeywords} keywords and filtered top 50 based on monthly searches.`,
              false
            );
            } else {
            await addMessageToChat(
              "I couldn't find any keywords for your topic. Let's continue with the blog generation anyway.",
              false
            );
            }

            // Continue with blog generation...
        } catch (error) {
          console.error(
            "Error in prompt refinement or keyword generation:",
            error
          );
          addMessageToChat(
            "I encountered an error while processing keywords, but I'll continue with the blog generation.",
            false
          );
        } finally {
            // Hide keyword loading animation and show blog generation loading
          const keywordLoadingOverlay = document.getElementById(
            "keyword-loading-overlay"
          );
          const chatInputContainer = document.querySelector(
            ".chat-input-container"
          );
          keywordLoadingOverlay.style.display = "none";
            keywordAnimation.stop();
            
            // Show the chat input container again if on mobile
            if (window.innerWidth <= 426) {
            chatInputContainer.style.display = "flex";
            }
            
            // Show the blog generation loading overlay
          const loadingOverlay = document.getElementById("loading-overlay");
          loadingOverlay.style.display = "flex";
        }

        // Add AI response about generating blog
        await addMessageToChat(
          "Now, I'll help you generate a blog post about this topic. Let me work on that for you...",
          false
        );
        
        addMessageToChat(
          "Generating your blog post<span class='loading-dots'></span>",
          false
        );
        
        // Show loading overlay and start appropriate animation
        const loadingOverlay = document.getElementById("loading-overlay");
        loadingOverlay.style.display = "flex";
        
        // Hide all animations first
        document.getElementById("lottie-loader").style.display = "none";
        document.getElementById("lottie-loader-image").style.display = "none";

          document.getElementById("lottie-loader-image").style.display =
            "block";
            if (lottieImageAnimation) {
            lottieImageAnimation.play();
        }
        
        try {
            // Show initial blog generation message
          const loadingText = loadingOverlay.querySelector("p");
          loadingText.innerHTML =
            'Generating your blog post<span class="loading-dots"></span>';
            
            // Check if message is too long (over 1000 characters)
            if (message.length > 1000) {
                console.warn("Long message detected, this might cause issues with the external API");
                addMessageToChat("Your topic is quite detailed. I'll do my best to generate a comprehensive blog post, but if there are issues, consider simplifying your request.", false);
            }
            
            // Implement retry logic for content generation
            let retries = 0;
            const maxRetries = 2;
            let content = null;
            let lastError = null;
            
            while (retries <= maxRetries) {
                try {
                    // If this is a retry, update the loading message
                    if (retries > 0) {
                        loadingText.innerHTML = 
                            `Retry attempt ${retries}/${maxRetries}: Generating your blog post<span class="loading-dots"></span>`;
                        
                        // Also add a message in the chat
                        addMessageToChat(
                            `I encountered an issue with the blog generation. Retrying (attempt ${retries}/${maxRetries})...`, 
                            false
                        );
                    }
                    
                    // Generate content
                    content = await generateContent(message);
                    
                    // If we got content successfully, break out of the retry loop
                    if (content) {
                        break;
                    }
                } catch (genError) {
                    lastError = genError;
                    console.error(`Content generation attempt ${retries + 1} failed:`, genError);
                    
                    // If we've reached max retries, throw the error to be caught by the outer catch block
                    if (retries >= maxRetries) {
                        throw genError;
                    }
                    
                    // Wait before retrying (exponential backoff)
                    const delay = Math.min(2000 * Math.pow(2, retries), 8000);
                    console.log(`Waiting ${delay}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    
                    retries++;
                }
            }
            
            // Check if generation was cancelled
            if (!content) {
                addMessageToChat("Blog generation was cancelled or failed after multiple attempts.", false);
                return;
            }

            updateEditorContent(content);

            // Add success message for blog generation
          addMessageToChat(
            "Great! I've generated your blog post. Now, let me create some relevant images to enhance your content...",
            false
          );

            // Update loading text for image generation
          loadingText.innerHTML =
            'Generating images for the blog<span class="loading-dots"></span>';

            // Generate and log image prompts
          const tempDiv = document.createElement("div");
            tempDiv.innerHTML = content;

            // Extract headings and key paragraphs
          const headings = Array.from(tempDiv.getElementsByTagName("h3")).map(
            (h) => h.textContent
          );
          const paragraphs = Array.from(tempDiv.getElementsByTagName("p")).map(
            (p) => p.textContent
          );

            // Show humanize loading overlay and start animation
          const humanizeLoadingOverlay = document.getElementById(
            "humanize-loading-overlay"
          );
          humanizeLoadingOverlay.style.display = "flex";
            if (humanizeAnimation) {
                humanizeAnimation.play();
            }

            // Humanize the content
            const humanizedContent = await humanizeContent(tempDiv.innerHTML);
            tempDiv.innerHTML = humanizedContent;
            
            // Immediately hide humanize loading overlay and stop animation
          humanizeLoadingOverlay.style.display = "none";
            if (humanizeAnimation) {
                humanizeAnimation.stop();
            }
            
            // Show the image loading animation
          const lottieImageContainer = document.getElementById(
            "lottie-loader-image"
          );
          lottieImageContainer.style.display = "block";
            if (lottieImageAnimation) {
                lottieImageAnimation.play();
            }
            
            // Add success message for humanization
          addMessageToChat(
            "Content has been successfully humanized! Now generating images...",
            false
          );

            // Create prompts based on the content
            const prompts = [];
            
            // First prompt based on main heading
          const mainHeading =
            tempDiv.getElementsByTagName("h1")[0]?.textContent;
            if (mainHeading) {
            prompts.push(`
                You are an expert creative image generator for blog articles. Given a specific topic ${mainHeading}, generate a detailed, vivid, and coherent prompt for an image that will visually support and enhance a blog post about that topic. The image should be:

                Visually engaging and relevant to the topic.

                In a style suitable for blog use (modern, clean, and illustrative or semi-realistic).
                `);
            } else {
            prompts.push(`
               You are an expert visual storyteller and blog content illustrator. Your task is to generate a creative and relevant image prompt based on a given blog topic. The image should:Clearly convey the core idea or emotion of the topic.Be suitable for professional blogs: clean, visually appealing, and non-gimmicky.Avoid text, logos, or watermarks.Work well as a blog cover image or section illustration.
                Format your output like this:
                Topic: ${message}
                Prompt: [Describe the image scene with details‚Äîobjects, environment, mood, etc.]
                Visual Style: [flat design / isometric / photorealistic / 3D / watercolor / minimalistic, etc.]
                Color Mood: [warm / cool / vibrant / neutral / pastel]
                Aspect Ratio: [16:9 preferred]
                ‚úÖ Example with Topic = "Sustainable Living Tips"
                Topic: Sustainable Living Tips
                Prompt: A sunny kitchen with reusable glass jars, leafy vegetables, a paper grocery bag, and a compost bin on the counter. A person is watering indoor plants while wearing casual home clothes. Sunlight streams through a window with a cityscape in the background.
                Visual Style: Clean digital illustration
                Color Mood: Warm and natural
                Aspect Ratio: 16:9
                `);
            }

            // Use subheadings as prompts for remaining images
            if (headings.length > 0) {
                headings.forEach((heading, index) => {
              if (index < 2) {
                // Only use first two subheadings to keep total of 3 images
                const relatedParagraph = paragraphs[index] || "";
                        const context = relatedParagraph.substring(0, 150);
                prompts.push(`
                        Create a detailed and professional image for the section: ${heading}. Context: ${context}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post section.
                        `);
                    }
                });
            } else if (paragraphs.length > 0) {
                // Fallback if no subheadings
                const mainContent = paragraphs[0].substring(0, 150);
            const conclusion = paragraphs[paragraphs.length - 1].substring(
              0,
              150
            );
            prompts.push(
              `Create a detailed and professional image for the main content: ${mainContent}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post.`
            );
            prompts.push(
              `Create a detailed and professional image for the conclusion: ${conclusion[
                conclusion.length - 1
              ].substring(
                0,
                150
              )}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post conclusion.`
            );
            } else {
            prompts.push(
              `Create a detailed and professional image for the topic: ${message}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post.`
            );
            prompts.push(
              `Create a detailed and professional image for the key concept: ${message}. Style: modern, clean, and visually appealing. Make it suitable for a professional blog post.`
            );
            }

            // Show loading message for all images
          addMessageToChat(
            'Generating all images<span class="loading-dots"></span>',
            false
          );

            // Generate all images in parallel
          const imagePromises = prompts.map((prompt) => generateImage(prompt));
            const imageResults = await Promise.all(imagePromises);

            // Remove loading message
          const chatMessages = document.getElementById("chat-messages");
            const loadingMessage = chatMessages.lastElementChild;
            if (loadingMessage) {
                chatMessages.removeChild(loadingMessage);
            }

            // Add processing message
          addMessageToChat(
            "Processing and optimizing the generated images...",
            false
          );

            // Process all generated images
            for (let i = 0; i < imageResults.length; i++) {
                const imageUrls = imageResults[i];
                if (imageUrls && imageUrls.length > 0) {
                    // Add the generated image to the chat
                    
              addMessageToChat(
                "Image generated successfully!",
                false,
                imageUrls
              );
                    
                    // Create image container with caption
              const imageContainer = document.createElement("div");
              imageContainer.className = "blog-image-container";
              imageContainer.style.margin = "2em 0";
              imageContainer.style.textAlign = "center";

                    // Create the image element
              const img = document.createElement("img");
                    img.src = imageUrls[0];
                    img.alt = `Generated image ${i + 1}`;
              img.style.maxWidth = "100%";
              img.style.height = "auto";
              img.style.borderRadius = "8px";
              img.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
              img.style.marginBottom = "0.5em";

                    // Create caption with URL
              const caption = document.createElement("p");
              caption.className = "image-caption";
              caption.style.fontSize = "0.9em";
              caption.style.color = "#666";
              caption.style.fontStyle = "italic";
              caption.style.margin = "0.5em 0";
              caption.innerHTML = `Figure ${i + 1}: ${
                prompts[i]
              }<br><span style="font-size: 0.8em; color: #888;">Image URL: <a href="${
                imageUrls[0]
              }" target="_blank">${imageUrls[0]}</a></span>`;

                    // Add image and caption to container
                    imageContainer.appendChild(img);
                    imageContainer.appendChild(caption);

                    // Get current content
                    const currentContent = quill.root.innerHTML;
                    let newContent;

                    // Insert image at appropriate location
                    if (i === 0) {
                        // Insert after main heading
                newContent = currentContent.replace(
                  "</h1>",
                  `</h1>${imageContainer.outerHTML}`
                );
                    } else if (i === 1 && headings.length > 0) {
                        // Insert after first subheading
                        const headingIndex = currentContent.indexOf(headings[0]);
                        if (headingIndex !== -1) {
                  const afterHeading =
                    currentContent.indexOf("</h3>", headingIndex) + 5;
                  newContent =
                    currentContent.slice(0, afterHeading) +
                    imageContainer.outerHTML +
                    currentContent.slice(afterHeading);
                        }
                    } else {
                        // Insert before conclusion
                const conclusionIndex = currentContent.lastIndexOf("<h2>");
                        if (conclusionIndex !== -1) {
                  newContent =
                    currentContent.slice(0, conclusionIndex) +
                    imageContainer.outerHTML +
                    currentContent.slice(conclusionIndex);
                        } else {
                            newContent = currentContent + imageContainer.outerHTML;
                        }
                    }

                    // Update the editor content
                    quill.root.innerHTML = newContent;
                }
            }

            // Update localStorage with the new content including images
          localStorage.setItem("BlogGenerated", quill.root.innerHTML);
        
        // Automatically save the complete blog (with images) to MongoDB
        try {
            // Add a small delay to ensure all images are properly added to chat DOM
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await autoSaveBlogToMongoDB(quill.root.innerHTML, message);
        } catch (error) {
            console.error("Error auto-saving blog:", error);
            addMessageToChat(
              "Note: There was an error auto-saving the blog.",
              false
            );
        }
            
            // Add completion message
          addMessageToChat(
            "All images have been generated and added to your blog post!",
            false
          );

            // Analyze and display keyword usage
            const blogContent = quill.getText(); // Get plain text content
            const keywordCounts = analyzeKeywordUsage(blogContent);
            displayKeywordUsage(keywordCounts);
        } catch (error) {
          console.error("Error generating content:", error);
          
          // Provide more specific error messages based on the error type
          let errorMessage = "Sorry, there was an error generating the content.";
          
          if (error.message) {
              // Check for specific error types
              if (error.message.includes("Failed to fetch") || error.message.includes("net::ERR_FAILED")) {
                  errorMessage = "Network error: Unable to connect to the content generation service. Please check your internet connection and try again.";
              } else if (error.message.includes("API error: 500") || error.message.includes("Internal server error")) {
                  errorMessage = "The content generation service encountered an internal error. This might be due to the complexity or length of your request. Please try again with a simpler or shorter topic.";
              } else if (error.message.includes("API error: 401") || error.message.includes("Authentication failed")) {
                  errorMessage = "Authentication error: Your session may have expired. Please log in again.";
                  // Redirect to login page after a short delay
                  setTimeout(() => {
                      window.location.href = "login.html";
                  }, 3000);
              } else if (error.message.includes("timeout") || error.message.includes("Timed out")) {
                  errorMessage = "The request timed out. This might be due to high server load or a slow internet connection. Please try again later.";
              } else if (error.message.includes("Invalid response format")) {
                  errorMessage = "The content generation service returned an invalid response. Please try again or contact support if the issue persists.";
              }
          }
          
          // Add the error message to the chat
          addMessageToChat(errorMessage, false);
          
          // For network errors, add a suggestion to check the API endpoint
          if (error.message && error.message.includes("Failed to fetch")) {
              addMessageToChat(
                "Tip: If this error persists, the content generation service might be temporarily unavailable. Please try again later or contact support.",
                false
              );
          }
        } finally {
            // Hide loading overlay
          loadingOverlay.style.display = "none";
          
          // Stop any running animations
          if (lottieAnimation) lottieAnimation.stop();
          if (lottieImageAnimation) lottieImageAnimation.stop();
          if (humanizeAnimation) humanizeAnimation.stop();
    }
}

// Update the copy button functionality
      document.getElementById("copy-button").addEventListener("click", () => {
    const content = quill.getText(); // Get plain text instead of HTML
    navigator.clipboard.writeText(content).then(() => {
          // Show toastify notification instead of alert
          Toastify({
            text: "Blog content copied to clipboard!",
            duration: 3000,
            gravity: "bottom",
            position: "right",
            backgroundColor: "#00b894",
            color: "#ffffff",
            stopOnFocus: true,
            close: true,
            style: {
              background: "linear-gradient(135deg, #00b894, #00a085)",
              borderRadius: "8px",
              boxShadow: "0 4px 12px rgba(0, 184, 148, 0.3)",
              fontSize: "14px",
              fontWeight: "500"
            }
          }).showToast();
    }).catch(() => {
          // Show error notification if copy fails
          Toastify({
            text: "‚ùå Failed to copy blog content",
            duration: 3000,
            gravity: "bottom",
            position: "right",
            backgroundColor: "#e74c3c",
            color: "#ffffff",
            stopOnFocus: true,
            close: true,
            style: {
              background: "linear-gradient(135deg, #e74c3c, #c0392b)",
              borderRadius: "8px",
              boxShadow: "0 4px 12px rgba(231, 76, 60, 0.3)",
              fontSize: "14px",
              fontWeight: "500"
            }
          }).showToast();
});
});


// Function to generate image prompts from blog content
async function generateImagePromptsFromBlog() {
    try {
        // Get the saved blog content
          const savedBlog = localStorage.getItem("BlogGenerated");
        if (!savedBlog) {
            throw new Error("No blog content found in localStorage");
        }

        // Create a temporary div to parse the HTML content
          const tempDiv = document.createElement("div");
        tempDiv.innerHTML = savedBlog;

        // Extract headings and key paragraphs
          const headings = Array.from(tempDiv.getElementsByTagName("h3")).map(
            (h) => h.textContent
          );
          const paragraphs = Array.from(tempDiv.getElementsByTagName("p")).map(
            (p) => p.textContent
          );

        // Create prompts based on the content
        const prompts = [];
        
        // First prompt based on main heading
          const mainHeading =
            tempDiv.getElementsByTagName("h1")[0]?.textContent;
        if (mainHeading) {
            console.log(`${mainHeading}`);
            prompts.push(
              `You are an expert creative image generator for blog articles. Given a specific topic ${mainHeading}, generate a detailed, vivid, and coherent prompt for an image that will visually support and enhance a blog post about that topic. The image should be:

                Visually engaging and relevant to the topic.

                In a style suitable for blog use (modern, clean, and illustrative or semi-realistic).`
            );
        }

        // Second prompt based on first subheading and its content
        if (headings.length > 0 && paragraphs.length > 0) {
            prompts.push(
              `You are an expert visual storyteller and blog content illustrator. Your task is to generate a creative and relevant image prompt based on a given blog topic. The image should:

                Clearly convey the core idea or emotion of the topic ${headings[0]} - ${paragraphs}.

                Be suitable for professional blogs: clean, visually appealing, and non-gimmicky.

                Avoid text, logos, or watermarks.

                Work well as a blog cover image or section illustration.
                NOTE: Make the image different from the previous image.
                `
            );
        }

        // Third prompt based on conclusion or last section
        const conclusion = paragraphs[paragraphs.length - 1];
        if (conclusion) {
            prompts.push(
                console.log(`${conclusion}`),
              `Create a visual representation of the conclusion: ${conclusion}`
            );
        }

        // Log the generated prompts
        
          prompts.forEach((prompt, index) => {});

        // Generate images for each prompt
        for (let i = 0; i < prompts.length; i++) {
            const prompt = prompts[i];
            addMessageToChat(
              `Generating image ${i + 1} based on: ${prompt}`,
              false
            );
            
            const imageUrls = await generateImage(prompt);
            if (imageUrls && imageUrls.length > 0) {
                // Add the generated image to the chat
              addMessageToChat(
                "Image generated successfully!",
                false,
                imageUrls
              );
                
                // Create image container with caption
              const imageContainer = document.createElement("div");
              imageContainer.className = "blog-image-container";
              imageContainer.style.margin = "2em 0";
              imageContainer.style.textAlign = "center";

                // Create the image element
              const img = document.createElement("img");
                img.src = imageUrls[0];
                img.alt = `Generated image ${i + 1}`;
              img.style.maxWidth = "100%";
              img.style.height = "auto";
              img.style.borderRadius = "8px";
              img.style.boxShadow = "0 4px 12px rgba(0,0,0,0.1)";
              img.style.marginBottom = "0.5em";

                // Create caption
              const caption = document.createElement("p");
              caption.className = "image-caption";
              caption.style.fontSize = "0.9em";
              caption.style.color = "#666";
              caption.style.fontStyle = "italic";
              caption.style.margin = "0.5em 0";
                caption.textContent = `Figure ${i + 1}: ${prompt}`;

                // Add image and caption to container
                imageContainer.appendChild(img);
                imageContainer.appendChild(caption);

                // Get current content
                const currentContent = quill.root.innerHTML;
                let newContent;

                // Insert image at appropriate location
                if (i === 0) {
                    // Insert after main heading
                newContent = currentContent.replace(
                  "</h1>",
                  `</h1>${imageContainer.outerHTML}`
                );
                } else if (i === 1 && headings.length > 0) {
                    // Insert after first subheading
                    const headingIndex = currentContent.indexOf(headings[0]);
                    if (headingIndex !== -1) {
                  const afterHeading =
                    currentContent.indexOf("</h3>", headingIndex) + 5;
                  newContent =
                    currentContent.slice(0, afterHeading) +
                    imageContainer.outerHTML +
                    currentContent.slice(afterHeading);
                    }
                } else {
                    // Insert before conclusion
                const conclusionIndex = currentContent.lastIndexOf("<h2>");
                    if (conclusionIndex !== -1) {
                  newContent =
                    currentContent.slice(0, conclusionIndex) +
                    imageContainer.outerHTML +
                    currentContent.slice(conclusionIndex);
                    } else {
                        newContent = currentContent + imageContainer.outerHTML;
                    }
                }

                // Update the editor content
                quill.root.innerHTML = newContent;

                // Add a small delay between image generations
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
        }

        // Update localStorage with the new content including images
          localStorage.setItem("BlogGenerated", quill.root.innerHTML);
        
          addMessageToChat(
            "All images have been generated and added to your blog post!",
            false
          );
    } catch (error) {
          console.error("Error generating images:", error);
          addMessageToChat(
            "Sorry, there was an error generating the images. Please try again.",
            false
          );
    }
}

// Add styles for the new button
      const style = document.createElement("style");
style.textContent = `
    .action-button {
        background: #6c5ce7;
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-left: 10px;
        opacity: 1;
        visibility: visible;
    }

    .action-button.loading {
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
    }

    .action-button:hover {
        background: #5f4dd0;
        transform: scale(1.05);
    }

    #generate-image-button {
        background: linear-gradient(135deg, #00b894, #00a884);
        border-radius: 25px;
        width: auto;
        height: 40px;
        padding: 0 20px;
        font-size: 0.95rem;
        font-weight: 500;
        letter-spacing: 0.3px;
        box-shadow: 0 4px 15px rgba(0, 184, 148, 0.2);
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        border: none;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    #generate-image-button:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateX(-100%);
    }

    #generate-image-button:hover {
        background: linear-gradient(135deg, #00a884, #009b77);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 184, 148, 0.3);
    }

    #generate-image-button:hover:before {
        transform: translateX(100%);
    }

    #generate-image-button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 10px rgba(0, 184, 148, 0.2);
    }

    #generate-image-button i {
        font-size: 1rem;
        transition: transform 0.3s ease;
    }

    #generate-image-button:hover i {
        transform: rotate(15deg);
    }

    .generated-images-button {
        background: linear-gradient(135deg, #6c5ce7, #5f4dd0);
        border-radius: 25px;
        height: 40px;
        padding: 0 20px;
        font-size: 0.95rem;
        font-weight: 500;
        letter-spacing: 0.3px;
        box-shadow: 0 4px 15px rgba(108, 92, 231, 0.2);
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        border: none;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    .generated-images-button:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
        transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateX(-100%);
    }

    .generated-images-button:hover {
        background: linear-gradient(135deg, #5f4dd0, #4a3dbf);
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(108, 92, 231, 0.3);
    }

    .generated-images-button:hover:before {
        transform: translateX(100%);
    }

    .generated-images-button:active {
        transform: translateY(1px);
        box-shadow: 0 2px 10px rgba(108, 92, 231, 0.2);
    }

    .generated-images-button i {
        font-size: 1rem;
        transition: transform 0.3s ease;
    }

    .generated-images-button:hover i {
        transform: rotate(15deg);
    }

    @media (max-width: 540px) {
        #generate-image-button,
        .generated-images-button {
            font-size: 0.85rem;
            padding: 0 15px;
            height: 36px;
        }
    }

    @media (max-width: 560px) {
        #generate-image-button,
        .generated-images-button {
            height: 32px;
        }

        .generated-images-button span{
            font-size: 7px;
        }

        #generate-image-button span{
            font-size: 8px !important;
    }

    #removeImageBtn {
        background: #e74c3c;
        color: white;
    }

    #removeImageBtn:hover {
        background: #c0392b;
    }
`;
document.head.appendChild(style);

// Add styles for blog images
      const imageStyles = document.createElement("style");
imageStyles.textContent = `
    .blog-image-container {
        text-align: center;
    }

    .blog-image-container img {
        max-width: 100%;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        transition: transform 0.3s ease;
    }

    .blog-image-container img:hover {
        transform: scale(1.02);
    }

    @media (max-width: 540px) {
        .blog-image-container {
            margin: 1.5em 0;
        }

        #generate-image-button{
         font-size: 12px;
        }

        .blog-image-container img {
            border-radius: 6px;
        }
    }
`;
document.head.appendChild(imageStyles);

// Add styles for action buttons
      const actionButtonStyles = document.createElement("style");
actionButtonStyles.textContent = `
    .output-actions {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .action-button {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.3s ease;
        color: white;
        padding: 0;
        margin: 0;
    }

    .action-button i {
        font-size: 16px;
    }

    .action-button:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    /* Keep the special styling for generate image button */
    #generate-image-button {
        border-radius: 20px;
        width: auto;
        height: 32px;
        padding: 0 15px;
        background: linear-gradient(135deg, #00b894, #00a884);
    }

    /* Keep the special styling for generated images button */
    .generated-images-button {
        border-radius: 20px;
        width: auto;
        height: 32px;
        padding: 0 15px;
        background: linear-gradient(135deg, #6c5ce7, #5f4dd0);
    }

    @media (max-width: 540px) {
        .output-actions {
            gap: 6px;
        }

        .action-button {
            width: 32px;
            height: 32px;
        }

        .action-button i {
            font-size: 14px;
        }
    }

    @media (max-width: 560px) {
        .output-actions {
            gap: 4px;
        }

        .action-button {
            width: 28px;
            height: 28px;
        }

        .action-button i {
            font-size: 12px;
        }

        #generate-image-button,
        .generated-images-button {
            height: 28px;
        }
    }
`;
document.head.appendChild(actionButtonStyles);

// Function to toggle action buttons visibility
function toggleActionButtons(show) {
        const actionButtons = document.querySelectorAll(
          ".action-button:not(#generate-image-button):not(.generated-images-button)"
        );
        actionButtons.forEach((button) => {
        if (show) {
            button.classList.remove("loading");
        } else {
            button.classList.add("loading");
        }
    });
}

// Update the heading item click handler
      document
        .getElementById("generate-image-button")
        .addEventListener("click", function (e) {
    e.stopPropagation();
          const dropdown = document.getElementById("headings-dropdown");
          const dropdownContent = dropdown.querySelector(".dropdown-content");
    
    // Clear previous content
          dropdownContent.innerHTML = "";
    
    // Get all h3 headings
          const headings = Array.from(quill.root.getElementsByTagName("h3"));
    
    if (headings.length > 0) {
        // Add each heading to the dropdown
        headings.forEach((heading, index) => {
              const headingItem = document.createElement("div");
              headingItem.className = "heading-item";
            headingItem.innerHTML = `
                <i class="fa-solid fa-image"></i>
                <span>${heading.textContent.trim()}</span>
            `;
            
            // Add click handler for individual heading
              headingItem.addEventListener("click", async function () {
                dropdown.style.display = "none";
                
                // Add chat message when user clicks on generate image option
                const headingText = heading.textContent.trim();
                addMessageToChat(
                  `Generating image for section: "${headingText}"...`,
                  false
                );
                
                // Show loading state with specific heading info
                const loadingOverlay =
                  document.getElementById("loading-overlay");
                const loadingText = loadingOverlay.querySelector("p");
                loadingText.innerHTML = `Generating image for section: "${headingText}"<span class="loading-dots"></span>`;
                loadingOverlay.style.display = "flex";
                
                try {
                    // Update loading text to show progress
                    loadingText.innerHTML = `Creating AI image for "${headingText}"<span class="loading-dots"></span>`;
                    
                    // Generate image based on heading
                    // Show image generation loader
                  document.getElementById("lottie-loader").style.display =
                    "none";
                  document.getElementById("lottie-loader-image").style.display =
                    "block";
                    
                    const imageUrls = await generateImage(headingText);
                    
                    if (imageUrls && imageUrls.length > 0) {
                        // Update loading text to show processing
                        loadingText.innerHTML = `Processing and optimizing image for "${headingText}"<span class="loading-dots"></span>`;
                        
                        // Ensure editor is focused and get cursor position
                        quill.focus();
                        const range = quill.getSelection(true); // Force focus and get selection
                        let insertIndex;
                        
                        if (range && range.index !== null) {
                            insertIndex = range.index;
                      addMessageToChat(
                        `üìç Image will be inserted at cursor position ${insertIndex}`,
                        false
                      );
                        } else {
                            // If no selection, insert at the end
                            insertIndex = quill.getLength() - 1;
                      addMessageToChat(
                        `üìç No cursor detected, image will be inserted at the end of the document`,
                        false
                      );
                        }
                        
                        // Insert image at cursor position
                    quill.insertEmbed(insertIndex, "image", imageUrls[0]);
                        
                        // Add some spacing after the image
                    quill.insertText(insertIndex + 1, "\n\n");
                        
                        // Set cursor after the inserted image
                        quill.setSelection(insertIndex + 3);
                        
                        // Update localStorage
                    localStorage.setItem("BlogGenerated", quill.root.innerHTML);
                        
                        // Add success chat message
                    addMessageToChat(
                      `‚úÖ Image generated successfully for "${headingText}" and added to your blog at position ${insertIndex}!`,
                      false
                    );
                        
                        // Update loading text to show completion
                        loadingText.innerHTML = `Image generated successfully for "${headingText}"!`;
                        setTimeout(() => {
                            // Hide all loaders
                      document.getElementById("lottie-loader").style.display =
                        "none";
                      document.getElementById(
                        "lottie-loader-image"
                      ).style.display = "none";
                      loadingOverlay.style.display = "none";
                        }, 1000);
                    }
                } catch (error) {
                  console.error("Error generating image:", error);
                  addMessageToChat(
                    `‚ùå Sorry, there was an error generating the image for "${headingText}". Please try again.`,
                    false
                  );
                    loadingText.innerHTML = `Error generating image for "${headingText}"`;
                    setTimeout(() => {
                    loadingOverlay.style.display = "none";
                    }, 2000);
                }
            });
            
            dropdownContent.appendChild(headingItem);
        });
        
        // Show dropdown
            dropdown.style.display = "block";
    } else {
            addMessageToChat(
              "No sections found to generate images for.",
              false
            );
    }
});

// Update close handlers to remove overlay references
      document
        .querySelector(".close-dropdown")
        .addEventListener("click", function () {
          document.getElementById("headings-dropdown").style.display = "none";
});

// Close dropdown when clicking outside
      document.addEventListener("click", function (e) {
        const dropdown = document.getElementById("headings-dropdown");
        const generateButton = document.getElementById("generate-image-button");

        if (
          !dropdown.contains(e.target) &&
          !generateButton.contains(e.target)
        ) {
          dropdown.style.display = "none";
    }
});

// Update generate all button click handler to also hide action buttons
      document
        .querySelector(".generate-all-btn")
        .addEventListener("click", async function () {
          const dropdown = document.getElementById("headings-dropdown");
          dropdown.style.display = "none";
    
    // Show loading state
          const loadingOverlay = document.getElementById("loading-overlay");
          const loadingText = loadingOverlay.querySelector("p");
          loadingOverlay.style.display = "flex";
    
    try {
        // Get all h3 headings
            const headings = Array.from(quill.root.getElementsByTagName("h3"));
        
        if (headings.length > 0) {
              addMessageToChat(
                "üé® Generating images for all sections in your blog...",
                false
              );
            
            // Ensure editor is focused and get cursor position
            quill.focus();
            const initialRange = quill.getSelection(true); // Force focus and get selection
            let baseInsertIndex;
            
            if (initialRange && initialRange.index !== null) {
                baseInsertIndex = initialRange.index;
                addMessageToChat(
                  `üìç Images will be inserted at cursor position ${baseInsertIndex}`,
                  false
                );
            } else {
                // If no selection, insert at the end
                baseInsertIndex = quill.getLength() - 1;
                addMessageToChat(
                  `üìç No cursor detected, images will be inserted at the end of the document`,
                  false
                );
            }
            
            // Create an array to store all generated images
            const generatedImages = [];
            
            // Generate images for each heading
            for (let i = 0; i < headings.length; i++) {
                const heading = headings[i];
                const headingText = heading.textContent.trim();
                
                // Add chat message for each section being processed
                addMessageToChat(
                  `üîÑ Processing section ${i + 1}/${
                    headings.length
                  }: "${headingText}"`,
                  false
                );
                
                // Update loading text to show current progress
                loadingText.innerHTML = `Generating image ${i + 1} of ${
                  headings.length
                }: "${headingText}"<span class="loading-dots"></span>`;
                
                // Update loading text to show creation progress
                loadingText.innerHTML = `Creating AI image ${i + 1} of ${
                  headings.length
                }: "${headingText}"<span class="loading-dots"></span>`;
                
                const imageUrls = await generateImage(headingText);
                
                if (imageUrls && imageUrls.length > 0) {
                    // Store the generated image info
                    generatedImages.push({
                        url: imageUrls[0],
                        heading: headingText,
                    index: i + 1,
                    });
                    
                    // Update loading text to show processing
                  loadingText.innerHTML = `Processing image ${i + 1} of ${
                    headings.length
                  }: "${headingText}"<span class="loading-dots"></span>`;
                    
                    // Calculate insert position based on initial cursor position and previous insertions
                  const insertIndex = baseInsertIndex + i * 3; // 3 = 1 image + 2 newlines
                    
                    // Insert image at calculated position
                  quill.insertEmbed(insertIndex, "image", imageUrls[0]);
                    
                    // Add some spacing after the image
                  quill.insertText(insertIndex + 1, "\n\n");
                    
                    // Add success message for each completed image
                  addMessageToChat(
                    `‚úÖ Image ${i + 1}/${
                      headings.length
                    } completed for "${headingText}" at position ${insertIndex}`,
                    false
                  );
                    
                    // Update loading text to show completion of current image
                  loadingText.innerHTML = `Completed image ${i + 1} of ${
                    headings.length
                  }: "${headingText}"`;
                    
                    // Add a small delay to show the completion message
                  await new Promise((resolve) => setTimeout(resolve, 500));
                } else {
                  addMessageToChat(
                    `‚ùå Failed to generate image for "${headingText}"`,
                    false
                  );
                }
            }
            
            // Set cursor after all inserted images
              const finalCursorPosition =
                baseInsertIndex + generatedImages.length * 3;
            quill.setSelection(finalCursorPosition);
            
            // Update localStorage
              localStorage.setItem("BlogGenerated", quill.root.innerHTML);
            
            // Add final success message
            const successCount = generatedImages.length;
              addMessageToChat(
                `üéâ All done! Successfully generated ${successCount}/${headings.length} images and added them to your blog!`,
                false
              );
            
            // Show final completion message
            loadingText.innerHTML = `All ${headings.length} images have been generated successfully!`;
            
            setTimeout(() => {
                loadingOverlay.style.display = "none";
            }, 2000);
        }
    } catch (error) {
            console.error("Error generating images:", error);
        loadingText.innerHTML = `Error generating images. Please try again.`;
        setTimeout(() => {
              loadingOverlay.style.display = "none";
            // Show action buttons again
            toggleActionButtons(true);
        }, 2000);
            addMessageToChat(
              "Sorry, there was an error generating the images.",
              false
            );
    }
});

// Close dropdown when clicking outside
      document.addEventListener("click", function (e) {
        const dropdown = document.getElementById("headings-dropdown");
        const generateButton = document.getElementById("generate-image-button");

        if (
          !dropdown.contains(e.target) &&
          !generateButton.contains(e.target)
        ) {
          dropdown.style.display = "none";
    }
});

// Add styles for loading dots animation
      const loadingStyles = document.createElement("style");
loadingStyles.textContent = `
    .loading-dots::after {
        content: '...';
        animation: loadingDots 1.5s infinite;
        display: inline-block;
        width: 20px;
        text-align: left;
    }

    @keyframes loadingDots {
        0% { content: '.'; }
        33% { content: '..'; }
        66% { content: '...'; }
    }

    #loading-overlay, #humanize-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        flex-direction: column;
        backdrop-filter: blur(5px);
        border-radius: 8px;
    }

    .blog-output {
        position: relative;
        padding: 0;
    }

    #loading-overlay p {
        margin-top: 20px;
        font-size: 16px;
        color: #2d3436;
        text-align: center;
        max-width: 80%;
        line-height: 1.5;
        font-weight: 500;
    }

    .loading-spinner {
        width: 60px;
        height: 60px;
        position: relative;
        display: none;
        align-items: center;
        justify-content: center;
    }

    .loading-spinner i {
        font-size: 32px;
        color: #6c5ce7;
        animation: twinkle 2s ease-in-out infinite;
    }

    @keyframes twinkle {
        0% {
            transform: scale(1);
            opacity: 1;
            text-shadow: 0 0 20px rgba(108, 92, 231, 0.5);
        }
        50% {
            transform: scale(1.1);
            opacity: 0.8;
            text-shadow: 0 0 30px rgba(108, 92, 231, 0.8);
        }
        100% {
            transform: scale(1);
            opacity: 1;
            text-shadow: 0 0 20px rgba(108, 92, 231, 0.5);
        }
    }

    .fade-in {
        animation: fadeIn 0.3s ease-in;
    }

    .fade-out {
        animation: fadeOut 0.3s ease-out;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    @keyframes fadeOut {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(10px); }
    }

    #lottie-loader, #lottie-loader-image {
        display: none;
    }

    #lottie-loader-image {
        margin: 0 auto;
    }

    @media (max-width: 560px) {
        .loading-spinner {
            display: none !important;
        }

        #loading-overlay p {
            display: block !important;
            font-size: 14px !important;
            color: #2d3436 !important;
            text-align: center !important;
            max-width: 90% !important;
            line-height: 1.4 !important;
            font-weight: 500 !important;
        }

        #lottie-loader {
            margin: 0 auto !important;
        }

        #loading-overlay {
            padding: 20px !important;
        }

        /* Make loader take full height of blog-generator for mobile */
        .blog-generator #loading-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 9999 !important;
            background: rgba(255, 255, 255, 0.98) !important;
            backdrop-filter: blur(8px) !important;
        }
    }

    @media (max-width: 540px) and (min-width: 427px) {
        /* Reduce font size for tablet devices (540px only) */
        .ql-editor {
            font-size: 15px !important;
            padding-bottom: 50px !important;
        }

        .action-button{
            width: 40px !important;
            height: 30px !important;
            margin-left: 0px !important;
        }

        .ql-editor h1 {
            font-size: 22px !important;
        }

        .ql-editor h2 {
            font-size: 20px !important;
        }

        .ql-editor h3 {
            font-size: 18px !important;
        }

        .ql-editor h4 {
            font-size: 16px !important;
        }

        .ql-editor p {
            font-size: 15px !important;
            line-height: 1.6 !important;
        }

        .ql-editor li {
            font-size: 15px !important;
        }

        /* Reduce chat message font sizes for tablet devices */
        .message-content {
            font-size: 14px !important;
        }

        .message-content p {
            font-size: 14px !important;
            line-height: 1.5 !important;
        }

        .message-time {
            font-size: 11px !important;
        }

        .ai-avatar, .user-avatar {
            font-size: 12px !important;
            width: 32px !important;
            height: 32px !important;
        }

        /* AI Avatar Loading Animation */
        .ai-avatar.loading {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #6c5ce7, #5f4dd0) !important;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .ai-avatar.loading::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 12px;
            height: 12px;
            margin: -6px 0 0 -6px;
            border: 1.5px solid transparent;
            border-top: 1.5px solid #ffffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }



        @keyframes pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(108, 92, 231, 0.7);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 0 4px rgba(108, 92, 231, 0);
            }
        }

        @keyframes spin {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }
    }

    /* Desktop AI Avatar Loading Animation */
    .ai-avatar.loading {
        position: relative;
        overflow: hidden;
        background: linear-gradient(135deg, #6c5ce7, #5f4dd0) !important;
        animation: pulse 1.5s ease-in-out infinite;
    }

    .ai-avatar.loading::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        margin: -8px 0 0 -8px;
        border: 1.5px solid transparent;
        border-top: 1.5px solid #ffffff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    

        .chat-input-container input {
            font-size: 14px !important;
        }

        .chat-header-content {
            font-size: 14px !important;
        }

        /* Reduce blog image sizes for tablet devices */
        .ql-editor img,
        .blog-image-container img,
        .blog-image {
            width: 300px !important;
            height: 300px !important;
            max-width: 300px !important;
            max-height: 300px !important;
            object-fit: cover !important;
            margin: 1em auto !important;
            display: block !important;
        }

        .blog-image-container {
            margin: 1em 0 !important;
            text-align: center !important;
        }

        .image-caption {
            font-size: 12px !important;
            margin: 0.5em 0 !important;
        }

        /* Reduce output-actions size for tablet devices */
        .output-actions {
            gap: 8px !important;
        }

        .action-button i {
            font-size: 16px !important;
        }

        .output-header h2{
            font-size: 18px;
        }

        #generate-image-button {
            font-size: 9px !important;
            padding: 8px !important;
            width: auto !important;
            height: 34px !important;
            border-radius: 17.5px !important;
        }

        .generated-images-button{
            font-size: 9px !important;
            padding: 8px !important;
            width: auto !important;
            height: 34px !important;
            border-radius: 17.5px !important;
        }
    }

    @media (min-width: 1024px) {
        .loading-spinner {
            display: none !important;
        }

        #loading-overlay p {
            display: block !important;
            font-size: 16px !important;
            color: #2d3436 !important;
            text-align: center !important;
            max-width: 80% !important;
            line-height: 1.5 !important;
            font-weight: 500 !important;
            margin-top: 20px !important;
        }

        #lottie-loader-image {
            display: block !important;
            margin: 0 auto !important;
        }

        #lottie-loader {
            display: none !important;
        }
    }
`;
document.head.appendChild(loadingStyles);

// Initialize Lottie animation
let lottieAnimation = null;
let lottieImageAnimation = null;
let humanizeAnimation = null;

function initializeLottieLoader() {
    // Destroy any existing animations first
    if (lottieAnimation) lottieAnimation.destroy();
    if (lottieImageAnimation) lottieImageAnimation.destroy();
    if (humanizeAnimation) humanizeAnimation.destroy();

    // Initialize based on screen width
    if (window.innerWidth <= 560) {
        lottieAnimation = lottie.loadAnimation({
            container: document.getElementById("lottie-loader"),
            renderer: "svg",
            loop: true,
            autoplay: false,
            path: "assets/blog-loader.json",
        });
    }
    
    // Initialize image generation loader
    lottieImageAnimation = lottie.loadAnimation({
          container: document.getElementById("lottie-loader-image"),
          renderer: "svg",
        loop: true,
        autoplay: false,
          path: "assets/blog-loader.json",
    });

    // Initialize humanize loader
    humanizeAnimation = lottie.loadAnimation({
          container: document.getElementById("humanize-loading-animation"),
          renderer: "svg",
        loop: true,
        autoplay: false,
          path: "assets/HumaniseLoading.json",
    });
}

// Initialize on page load
      document.addEventListener("DOMContentLoaded", initializeLottieLoader);

// Re-initialize on window resize
      window.addEventListener("resize", function () {
    initializeLottieLoader();
});

      const buttonStyles = document.createElement("style");
buttonStyles.textContent = `
    .send-button, .clear-button {
        background: none;
        border: none;
        cursor: pointer;
        padding: 10px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: absolute;
        right: 25px;
        overflow: hidden;
    }

    .send-button {
        color: #6c5ce7;
        background: rgba(108, 92, 231, 0.1);
    }

    .send-button:hover {
        color: #ffffff;
        background: #6c5ce7;
        transform: scale(1.1) rotate(5deg);
        box-shadow: 0 4px 12px rgba(108, 92, 231, 0.3);
    }

    .clear-button {
        color: #e74c3c;
        background: rgba(231, 76, 60, 0.1);
    }

    .clear-button:hover {
        color: #ffffff;
        background: #e74c3c;
        transform: scale(1.1) rotate(-5deg);
        box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
    }

    .send-button i, .clear-button i {
        font-size: 18px;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .send-button:hover i {
        transform: translateX(2px);
    }

    .clear-button:hover i {
        transform: translateX(-2px);
    }

    .send-button::after, .clear-button::after {
        content: '';
        position: absolute;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 70%);
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .send-button:hover::after, .clear-button:hover::after {
        opacity: 1;
    }
`;
document.head.appendChild(buttonStyles);

        // Update modal styles
      const modalStyles = document.createElement("style");
        modalStyles.textContent = `
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 0;
                height: 0;
                background: transparent;
                display: none;
                pointer-events: none;
            }

            .modal-content {
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 1001;
                position: fixed !important;
                /* Remove fixed positioning to allow dragging */
                /* top: 600px ; */
                /* left: 210px; */
                /* transform: translate(-50%, -50%) !important; */
                width: 300px !important;
                max-width: 400px !important;
                min-width: 250px !important;
                user-select: none;
            }
            
            /* Draggable modal styles */
            .modal-content .modal-header {
                cursor: move;
                user-select: none;
                border-radius: 8px 8px 0 0;
                margin: -15px -15px 15px -15px;
                padding: 15px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
            }
            
            .modal-content .modal-header:hover {
                background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
            }
            
            .modal-content .modal-header h3 {
                margin: 0;
                color: white;
            }
            
            .modal-content.dragging {
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
                transform: none !important;
            }

            /* Editor resizer positioning */
            .ql-resize-handle,
            .ql-resize-toolbar {
                position: fixed !important;
                top: 495px !important;
                left: 170px !important;
                z-index: 1000;
            }

            @media (max-width: 560px) {
                .modal-content {
                    /* Allow dragging on mobile too */
                    width: 280px !important;
                    max-width: 280px !important;
                    padding: 12px !important;
                }
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
                padding-bottom: 10px;
                border-bottom: 1px solid #eee;
            }

            .modal-title {
                font-size: 16px;
                margin: 0;
                text-align: left;
                cursor: move;
                user-select: none;
                flex-grow: 1;
            }

            .close-modal-btn {
                background: none;
                border: none;
                cursor: pointer;
                padding: 5px;
                margin-left: 10px;
                color: rgba(255, 255, 255, 0.8);
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                position: relative;
                z-index: 10;
            }

            .close-modal-btn:hover {
                background: rgba(255, 255, 255, 0.2);
                color: white;
                transform: rotate(90deg);
            }

            .close-modal-btn i {
                font-size: 18px;
            }

            .modal-buttons {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .modal-button {
                width: 100%;
                padding: 8px;
                font-size: 14px;
                position: relative;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 8px;
                transition: all 0.3s ease;
            }

            .modal-button.loading {
                pointer-events: none;
                opacity: 0.8;
            }

            .modal-button.loading .button-text {
                visibility: hidden;
            }

            .modal-button.loading::after {
                content: '';
                position: absolute;
                width: 20px;
                height: 20px;
                border: 2px solid #ffffff;
                border-radius: 50%;
                border-top-color: transparent;
                animation: button-spin 1s linear infinite;
            }

            @keyframes button-spin {
                to {
                    transform: rotate(360deg);
                }
            }

            .prompt-input-container {
                margin-top: 12px;
            }

            .prompt-input {
                width: 100%;
                padding: 8px;
                font-size: 14px;
            }

            .prompt-actions {
                display: flex;
                gap: 8px;
                margin-top: 8px;
            }

            @media (max-width: 540px) {
                .modal-content {
                    /* Allow dragging on mobile */
                    width: 320px !important;
                    max-width: 350px !important;
                }
            }

            @media (max-width: 560px) {
                .modal-content {
                    /* Allow dragging on mobile */
                    width: 280px !important;
                    max-width: 280px !important;
                    padding: 12px !important;
                }

                .modal-title {
                    font-size: 14px !important;
                }

                .modal-button {
                    padding: 6px !important;
                    font-size: 12px !important;
                }

                .prompt-input {
                    padding: 6px !important;
                    font-size: 12px !important;
                }

                .close-modal-btn {
                    width: 20px !important;
                    height: 20px !important;
                }

                .close-modal-btn i {
                    font-size: 14px !important;
                }
            }
        `;
        document.head.appendChild(modalStyles);

        // Add event listener for close button
      document
        .querySelector(".close-modal-btn")
        .addEventListener("click", function () {
          const modal = document.querySelector(".modal-content");
          modal.style.display = "none";
            // Also hide the overlay
          document.getElementById("imageModal").style.display = "none";
        });

        // Add click event listener for blog images
      document.addEventListener("click", function (e) {
        const modal = document.getElementById("imageModal");
        const modalContent = modal.querySelector(".modal-content");
            
            // If clicking outside the modal content (and modal is visible), hide the modal
        if (
          modal.style.display !== "none" &&
          !modalContent.contains(e.target) &&
          !e.target.closest(".ql-editor img") &&
          !e.target.closest(".modal-content")
        ) {
          modal.style.display = "none";
                return;
            }
            
            // Check if the clicked element is an image within the blog content
        if (e.target.tagName === "IMG" && e.target.closest(".ql-editor")) {
                // Get the image's position
                const imageRect = e.target.getBoundingClientRect();
          const editorRect = document
            .querySelector(".ql-editor")
            .getBoundingClientRect();
                
                // Calculate position relative to the editor
                const top = 300; // 10px gap from image
                const left = imageRect.left - editorRect.left;
                
                // Set fixed width for modal content
          modalContent.style.width = "250px";
          modalContent.style.minWidth = "250px";
          modalContent.style.maxWidth = "250px";
                
                // Position the modal content (use fixed for draggability)
          modalContent.style.position = "fixed";
                modalContent.style.top = `${Math.max(50, top)}px`;
                modalContent.style.left = `${Math.max(50, left)}px`;
          modalContent.style.transform = "none";
                
                // Show the modal
          modal.style.display = "flex";
          modalContent.style.display = "block";
          
          // Make the modal draggable
          makeDraggable(modalContent);
          
          // Ensure the modal is within viewport bounds
          setTimeout(() => {
              const rect = modalContent.getBoundingClientRect();
              if (rect.left < 0) modalContent.style.left = "10px";
              if (rect.top < 0) modalContent.style.top = "10px";
              if (rect.right > window.innerWidth) modalContent.style.left = (window.innerWidth - rect.width - 10) + "px";
              if (rect.bottom > window.innerHeight) modalContent.style.top = (window.innerHeight - rect.height - 10) + "px";
          }, 10);
                
                // Reset prompt input container visibility
          document.getElementById("promptInputContainer").style.display =
            "none";
            }
        });

        // Mobile Chat Toggle Styles
      const mobileChatToggleStyles = document.createElement("style");
        mobileChatToggleStyles.textContent = `
            .mobile-chat-toggle {
                display: none;
                background: #6c5ce7;
                color: white;
                border: none;
                border-radius: 50%;
                width: 45px;
                height: 45px;
                cursor: pointer;
                box-shadow: 0 2px 8px rgba(108, 92, 231, 0.3);
                transition: all 0.3s ease;
                font-size: 18px;
                position: fixed;
                bottom: 80px;
                right: 20px;
                z-index: 1002;
            }

            @media (max-width: 560px) {
                .mobile-chat-toggle {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
            }

            .back-to-chat-btn {
                display: none;
                width: 40px;
                height: 40px;
                cursor: pointer;
                transition: all 0.3s ease;
                margin-right: 15px;
                object-fit: contain;
            }

            .back-to-chat-btn:hover {
                transform: scale(1.1);
            }

            .back-to-chat-btn:active {
                transform: scale(0.95);
            }


            .mobile-chat-toggle:hover {
                background: #5f4dd0;
                transform: scale(1.1) translateY(-2px);
                box-shadow: 0 8px 16px rgba(108, 92, 231, 0.4);
            }

            .mobile-chat-toggle:active {
                transform: scale(0.95) translateY(0);
                box-shadow: 0 4px 8px rgba(108, 92, 231, 0.3);
            }

            .mobile-chat-toggle.chat-hidden i::before {
                content: "\\f086"; /* fa-comments */
            }

            .mobile-chat-toggle.chat-visible i::before {
                content: "\\f00d"; /* fa-times */
            }

            @media (max-width: 560px) {
                .mobile-chat-toggle {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .back-to-chat-btn {
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }

                .output-header {
                    display: flex;
                    align-items: center;
                    padding: 15px 20px;
                    width: 100vw;
                    border-bottom: 1px solid #e0e0e0;
                    position: sticky;
                    top: 0;
                    z-index: 100;
                }

                .output-header h2 {
                display: none;
                }

                .chat-header {
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    padding: 15px 20px;
                    flex-shrink: 0;
                    border-bottom: 1px solid #e0e0e0;
                    width: 100vw;
                }

                .chat-header-content {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .chat-section {
                    display: none;
                    transition: opacity 0.3s ease;
                    height: 100vh;
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    z-index: 1000;
                    width: 100vw;
                }
                
                @media (max-width: 560px) {
                    .chat-section {
                        display: flex !important;
                        width: 0px;
                    }
                    
                    .chat-section:not(.visible) .chat-messages,
                    .chat-section:not(.visible) .chat-header {
                        display: none;
                    }
                    
                    .chat-section .chat-input-container {
                        display: flex !important;
                        position: fixed;
                        bottom: 0;
                        background: white;
                        z-index: 1001;
                    }
                }

                .chat-section.visible {
                    display: flex;
                    flex-direction: column;
                }

                .chat-messages {
                    flex: 1;
                    overflow-y: auto;
                    padding: 20px;
                    padding-bottom: 5rem;
                    width: 100vw;
                    max-height: 100vh;
                }

                .chat-input-container {
                    position: fixed;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    width: 100vw;
                    z-index: 1001;
                }

                .output-section {
                    width: 100vw;
                }

                .blog-generator {
                    flex-direction: column;
                }

                .blog-output {
                    width: 100vw;
                    padding-bottom: 6rem;
                }

                /* Reduce font size for mobile devices */
                .ql-editor {
                    font-size: 14px !important;
                    padding: 12px 15px 140px 15px !important;
                    height: 100vh;
                }

                .ql-editor h1 {
                    font-size: 20px !important;
                }

                .ql-editor h2 {
                    font-size: 18px !important;
                }

                .ql-editor h3 {
                    font-size: 16px !important;
                }

                .ql-editor h4 {
                    font-size: 15px !important;
                }

                .ql-editor p {
                    font-size: 14px !important;
                    line-height: 1.5 !important;
                }

                .ql-editor li {
                    font-size: 14px !important;
                }

                /* Reduce image sizes for mobile devices */
                .ql-editor img,
                .blog-image-container img,
                .blog-image {
                    width: 200px !important;
                    height: 200px !important;
                    max-width: 200px !important;
                    max-height: 200px !important;
                    object-fit: cover !important;
                    margin: 1em auto !important;
                    display: block !important;
                }

                .blog-image-container {
                    margin: 1em 0 !important;
                    text-align: center !important;
                }

                .image-caption {
                    font-size: 12px !important;
                    margin: 0.5em 0 !important;
                }

                /* Reduce output-actions size for mobile devices */
                .output-actions {
                    gap: 5px !important;
                }

                .action-button {
                    width: 30px !important;
                    height: 30px !important;
                    margin-left: 5px !important;
                }

                .action-button i {
                    font-size: 14px !important;
                }

                #generate-image-button {
                    font-size: 10px !important;
                    padding: 4px !important;
                    width: auto !important;
                    height: 30px !important;
                    border-radius: 15px !important;
                    
                }
            }

            /* Add styles for 320px screens */
            @media (max-width: 320px) {
                .back-to-chat-btn {
                    width: 30px !important;
                    min-width: 30px !important;
                    height: 30px !important;
                    padding: 0 !important;
                    border-radius: 50% !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    margin-right: 0px !important;
                }

                .back-to-chat-btn i {
                    margin: 0 !important;
                    font-size: 14px !important;
                }

                .output-header h2 {
                    font-size: 16px !important;
                }
            }
        `;
        document.head.appendChild(mobileChatToggleStyles);

        // Mobile Chat Toggle Functionality
      const mobileChatToggle = document.getElementById("mobile-chat-toggle");
      const chatSection = document.getElementById("chat-section");
        let chatVisible = false; // Start with chat hidden on mobile

        // Initialize button state - start with chat hidden on mobile
        if (window.innerWidth <= 426) {
        chatSection.style.display = "flex";
        chatSection.classList.remove("visible");
        mobileChatToggle.classList.remove("chat-visible");
        mobileChatToggle.classList.add("chat-hidden");
            mobileChatToggle.innerHTML = '<i class="fa-solid fa-comments"></i>';
        }

      mobileChatToggle.addEventListener("click", function () {
            chatVisible = !chatVisible;
            
            if (chatVisible) {
          chatSection.style.display = "flex";
          chatSection.classList.add("visible");
          mobileChatToggle.classList.remove("chat-hidden");
          mobileChatToggle.classList.add("chat-visible");
                mobileChatToggle.innerHTML = '<i class="fa-solid fa-times"></i>';
                
                // Show chat header when chat is visible
          const chatHeader = document.querySelector(".chat-header");
                if (chatHeader) {
            chatHeader.style.display = "flex";
                }
            } else {
          chatSection.classList.remove("visible");
          mobileChatToggle.classList.remove("chat-visible");
          mobileChatToggle.classList.add("chat-hidden");
                mobileChatToggle.innerHTML = '<i class="fa-solid fa-comments"></i>';
                
                // Hide chat header when chat is not visible
          const chatHeader = document.querySelector(".chat-header");
            //     if (chatHeader) {
            // chatHeader.style.display = "none";
            //     }
            }
        });

        // Back to Chat Button Functionality
      const backToChatBtn = document.getElementById("back-to-chat-btn");
        
      backToChatBtn.addEventListener("click", function () {
            // Show chat section
            chatVisible = true;
        chatSection.style.display = "flex";
        chatSection.classList.add("visible");
        mobileChatToggle.classList.remove("chat-hidden");
        mobileChatToggle.classList.add("chat-visible");
            mobileChatToggle.innerHTML = '<i class="fa-solid fa-times"></i>';
        });

        // Add event listener for Generated Images button
      document
        .querySelector(".generated-images-button")
        .addEventListener("click", function () {
            // Get all images from the editor
          const images = quill.root.querySelectorAll(
            'img:not([src*="placeholder.svg"])'
          );
            
            if (images.length === 0) {
            addMessageToChat(
              "No generated images found in the blog post.",
              false
            );
                return;
            }

            // Create modal for displaying images
          const modal = document.createElement("div");
          modal.className = "images-modal";
            modal.innerHTML = `
                <div class="images-modal-content">
                    <div class="modal-header">
                        <h3>Generated Images</h3>
                        <button class="close-modal-btn">
                            <i class="fa-solid fa-xmark"></i>
                        </button>
                    </div>
                    <div class="images-tiles"></div>
                </div>
            `;

            // Add images to the tiles layout
          const imagesTiles = modal.querySelector(".images-tiles");
            images.forEach((img, index) => {
            const tileContainer = document.createElement("div");
            tileContainer.className = "tile";
                
                // Get the nearest heading before this image
                let heading = img.previousElementSibling;
            while (heading && !["H1", "H2", "H3"].includes(heading.tagName)) {
                    heading = heading.previousElementSibling;
                }
            const headingText = heading
              ? heading.textContent
              : "Image " + (index + 1);
                
                tileContainer.innerHTML = `
                    <div class="tile-content">
                        <img src="${img.src}" alt="${headingText}">
                        <div class="tile-overlay">
                            <h4>${headingText}</h4>
                            <p>Click image to insert to the blog</p>
                            <p class="copy-hint">Click here to copy URL</p>
                        </div>
                    </div>
                `;
                
                // Add click handler to copy image URL
            tileContainer.addEventListener("click", function (e) {
                    // Check if the click was on the overlay (for copying URL)
              if (e.target.closest(".tile-overlay")) {
                        navigator.clipboard.writeText(img.src);
                const p = this.querySelector("p");
                        const originalText = p.textContent;
                p.textContent = "URL copied!";
                        
                        // Add copied class for animation
                p.classList.add("copied");
                        
                        setTimeout(() => {
                            p.textContent = originalText;
                  p.classList.remove("copied");
                        }, 2000);
                    } else {
                        // Insert image at cursor position
                        const range = quill.getSelection(true);
                        if (range) {
                            // Insert a newline before the image if we're not at the start
                            if (range.index > 0) {
                    quill.insertText(range.index, "\n");
                            }
                            
                            // Insert the image with fixed dimensions
                  quill.insertEmbed(range.index + 1, "image", img.src);
                            
                            // Set fixed dimensions for the inserted image
                            setTimeout(() => {
                    const insertedImage = quill.root.querySelector(
                      `img[src="${img.src}"]`
                    );
                                if (insertedImage) {
                      insertedImage.style.width = "400px";
                      insertedImage.style.height = "400px";
                      insertedImage.style.objectFit = "cover";
                      insertedImage.style.display = "block";
                      insertedImage.style.margin = "2em auto";
                                }
                            }, 0);
                            
                            // Insert a newline after the image
                  quill.insertText(range.index + 2, "\n");
                            
                            // Set cursor after the image
                            quill.setSelection(range.index + 3, 0);
                            
                            // Update localStorage
                  localStorage.setItem("BlogGenerated", quill.root.innerHTML);
                            
                            // Close the modal
                  modal.classList.add("closing");
                            setTimeout(() => modal.remove(), 300);
                            
                            // Show success message
                            addMessageToChat("Image inserted at cursor position!", false);
                        } else {
                            // If no cursor position, insert at the end
                            const length = quill.getLength();
                  quill.insertEmbed(length - 1, "image", img.src);
                            
                            // Set fixed dimensions for the inserted image
                            setTimeout(() => {
                    const insertedImage = quill.root.querySelector(
                      `img[src="${img.src}"]`
                    );
                                if (insertedImage) {
                      insertedImage.style.width = "400px";
                      insertedImage.style.height = "400px";
                      insertedImage.style.objectFit = "cover";
                      insertedImage.style.display = "block";
                      insertedImage.style.margin = "2em auto";
                                }
                            }, 0);
                            
                  quill.insertText(length, "\n");
                            quill.setSelection(length + 1, 0);
                  localStorage.setItem("BlogGenerated", quill.root.innerHTML);
                            
                            // Close the modal
                  modal.classList.add("closing");
                            setTimeout(() => modal.remove(), 300);
                            
                            // Show success message
                  addMessageToChat(
                    "Image inserted at the end of the document!",
                    false
                  );
                        }
                    }
                });
                
                imagesTiles.appendChild(tileContainer);
            });

            // Add styles for the tiles layout
          const style = document.createElement("style");
            style.textContent = `
                .images-modal {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.85);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 2000;
                    backdrop-filter: blur(5px);
                }
                
                .images-modal-content {
                    background: white;
                    padding: 30px;
                    border-radius: 16px;
                    max-width: 95%;
                    max-height: 90vh;
                    overflow-y: auto;
                    position: relative;
                    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
                }
                
                /* Draggable styles for images modal */
                .images-modal-content .modal-header {
                    cursor: move;
                    user-select: none;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 15px 20px;
                    margin: -30px -30px 20px -30px;
                    border-radius: 16px 16px 0 0;
                }
                
                .images-modal-content .modal-header:hover {
                    background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
                }
                
                .images-modal-content .modal-header h3 {
                    margin: 0;
                    color: white;
                }
                
                .images-modal-content.dragging {
                    box-shadow: 0 12px 35px rgba(0, 0, 0, 0.3);
                    transform: none !important;
                }
                
                .modal-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 20px;
                    padding-bottom: 15px;
                    border-bottom: 2px solid #f0f0f0;
                }
                
                .modal-header h3 {
                    margin: 0;
                    font-size: 1.5rem;
                    color: #2d3436;
                    font-weight: 600;
                }
                
                .close-modal-btn {
                    background: none;
                    border: none;
                    color: #636e72;
                    cursor: pointer;
                    padding: 5px;
                    border-radius: 50%;
                    width: 32px;
                    height: 32px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.3s ease;
                }
                
                .close-modal-btn:hover {
                    background: #f0f0f0;
                    color: #2d3436;
                    transform: rotate(90deg);
                }
                
                .images-tiles {
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                    gap: 25px;
                    padding: 10px;
                }
                
                .tile {
                    position: relative;
                    border-radius: 12px;
                    overflow: hidden;
                    cursor: pointer;
                    aspect-ratio: 1;
                    transform-origin: center;
                    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
                
                .tile:hover {
                    transform: scale(1.02);
                }
                
                .tile-content {
                    position: relative;
                    width: 100%;
                    height: 100%;
                    cursor: pointer;
                }
                
                .tile-content img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 12px;
                    transition: transform 0.3s ease;
                }
                
                @media (max-width: 560px) {
                    .images-modal-content {
                        padding: 15px;
                        width: 90%;
                        max-height: 80vh;
                        margin: 10px;
                    }
                    
                    .modal-header {
                        margin-bottom: 12px;
                        padding-bottom: 8px;
                    }
                    
                    .modal-header h3 {
                        font-size: 1rem;
                    }
                    
                    .close-modal-btn {
                        width: 24px;
                        height: 24px;
                    }
                    
                    .close-modal-btn i {
                        font-size: 14px;
                    }
                    
                    .images-tiles {
                        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                        gap: 8px;
                        padding: 5px;
                    }
                    
                    .tile {
                        border-radius: 8px;
                    }
                    
                    .tile-content img {
                        border-radius: 8px;
                    }
                }
            `;
            document.head.appendChild(style);

            // Add close functionality
          const closeBtn = modal.querySelector(".close-modal-btn");
          closeBtn.addEventListener("click", () => {
            modal.classList.add("closing");
                setTimeout(() => modal.remove(), 300);
            });
          modal.addEventListener("click", (e) => {
                if (e.target === modal) {
              modal.classList.add("closing");
                    setTimeout(() => modal.remove(), 300);
                }
            });

            // Add modal to body
            document.body.appendChild(modal);
            
            // Make the images modal draggable
            const imagesModalContent = modal.querySelector(".images-modal-content");
            if (imagesModalContent) {
                makeDraggable(imagesModalContent);
            }
        });

        // Function to get top 50 keywords by average monthly searches
        function getTopKeywords() {
            // Get the generated keywords from localStorage
        const generatedKeywords = JSON.parse(
          localStorage.getItem("generatedKeywords") || "[]"
        );
            
            // Sort keywords by avg_monthly_searches in descending order
            const sortedKeywords = generatedKeywords.sort((a, b) => {
                // Ensure we're comparing numbers
          const aSearches =
            typeof a === "object" ? a.avg_monthly_searches || 0 : 0;
          const bSearches =
            typeof b === "object" ? b.avg_monthly_searches || 0 : 0;
                return bSearches - aSearches;
            });
            
            // Take top 50 keywords with their search volumes
        const top50Keywords = sortedKeywords.slice(0, 50).map((keyword) => ({
          keyword: typeof keyword === "object" ? keyword.keyword : keyword,
          avg_monthly_searches:
            typeof keyword === "object" ? keyword.avg_monthly_searches || 0 : 0,
            }));
            
            // Store in localStorage
        localStorage.setItem("top50Keywords", JSON.stringify(top50Keywords));
            
            return top50Keywords;
        }

        // Function to analyze keyword usage in blog content
        function analyzeKeywordUsage(content) {
            // Get the top 50 keywords from localStorage
        const top50Keywords = JSON.parse(
          localStorage.getItem("top50Keywords") || "[]"
        );
            
            // Create a map to store keyword counts
            const keywordCounts = new Map();
            
            // Convert content to lowercase for case-insensitive matching
            const lowerContent = content.toLowerCase();
            
            // Count occurrences of each keyword
        top50Keywords.forEach((keywordObj) => {
          const keyword = (
            typeof keywordObj === "object" ? keywordObj.keyword : keywordObj
          ).toLowerCase();
                
                // Use regex to find all occurrences (whole word matches only)
          const regex = new RegExp(`\\b${keyword}\\b`, "g");
                const matches = lowerContent.match(regex);
                
                if (matches) {
                    keywordCounts.set(keyword, matches.length);
                }
            });
            
            return keywordCounts;
        }

        // Function to display keyword usage in chat
        function displayKeywordUsage(keywordCounts) {
            if (keywordCounts.size === 0) {
          addMessageToChat(
            "No keywords from the target list were found in the blog content.",
            false
          );
                return;
            }
            
            // Convert to array and sort by count (descending)
        const sortedKeywords = Array.from(keywordCounts.entries()).sort(
          (a, b) => b[1] - a[1]
        );
            
            // Create message content with numbered list
            let message = "üìä Keyword Usage Analysis:\n\n";
            sortedKeywords.forEach(([keyword, count], index) => {
          message += `${index + 1}. "${keyword}": ${count} time${
            count !== 1 ? "s" : ""
          }\n`;
            });
            
            // Add total keywords found
            message += `\nTotal unique keywords found: ${sortedKeywords.length}`;
            
            // Add the message to chat
            addMessageToChat(message, false);
        }

        // Add this after your other script initialization code
        // Initialize Lottie animation
        const keywordAnimation = lottie.loadAnimation({
        container: document.getElementById("keyword-loading-animation"),
        renderer: "svg",
            loop: true,
            autoplay: false,
        path: "assets/keyword researching.json",
        });

        // Function to humanize content using our backend API
        async function humanizeContent(content) {
            try {
          const token = localStorage.getItem("token");
                if (!token) {
            throw new Error("No authentication token found");
                }

                const response = await fetch(`${API_URL}/blogs/humanize`, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
                    },
            body: JSON.stringify({ content }),
                });

                if (!response.ok) {
            throw new Error("Failed to humanize content");
                }

                const data = await response.json();
                return data.humanizedContent || content;
            } catch (error) {
          console.error("Error humanizing content:", error);
                // Return original content if humanization fails
                return content;
            }
        }

        // Add this function to initialize the chat with welcome message
        async function initializeChat() {
                    // Check if there are existing messages in the chat
        const chatMessages = document.getElementById("chat-messages");
        if (chatMessages.children.length === 0) {
            // Add the welcome message only if chat is empty and not restoring from history
            const isRestoring = localStorage.getItem("isRestoringChat");
            if (!isRestoring) {
                await addMessageToChat(
                    "Welcome to BlogMagic! I'm here to help you create amazing blog content.",
                    false
                );
            }
        }
        }

        // Call initializeChat when the page loads
      document.addEventListener("DOMContentLoaded", function () {
            initializeChat();
            // ... rest of your existing DOMContentLoaded code ...
        });

        // Functions from script.js that need to be included
        
        // Function to extract blog title from content
        function extractBlogTitle(content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const h1 = tempDiv.querySelector('h1');
            if (h1) {
                return h1.textContent.trim();
            }
            const h2 = tempDiv.querySelector('h2');
            if (h2) {
                return h2.textContent.trim();
            }
            // Extract first paragraph as title if no heading found
            const firstP = tempDiv.querySelector('p');
            if (firstP) {
                const text = firstP.textContent.trim();
                return text.length > 50 ? text.substring(0, 50) + '...' : text;
            }
            return 'Untitled Blog';
        }

        // Function to extract blog preview/summary from content
        function extractBlogPreview(content) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            
            // Remove headings and get text content
            const headings = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headings.forEach(heading => heading.remove());
            
            const text = tempDiv.textContent.trim();
            if (text.length > 150) {
                return text.substring(0, 150) + '...';
            }
            return text || 'No preview available';
        }
        
      window.loadBlogWithChatHistory = async function loadBlogWithChatHistory(
        blogId
      ) {
            try {
          const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}/with-chat`, {
                    headers: {
              Authorization: `Bearer ${token}`,
            },
                });

                if (!response.ok) {
            console.error("Failed to load blog, status:", response.status);
            throw new Error("Failed to load blog with chat history");
                }

                const data = await response.json();
                
                const blog = data.data.blog;

                // Restore blog content
                quill.root.innerHTML = blog.content;
          localStorage.setItem("BlogGenerated", blog.content);
                
                // Set current blog ID for further modifications
                currentBlogId = blog._id;
          localStorage.setItem("currentBlogId", blog._id);
                window.currentBlogId = localStorage.getItem("currentBlogId");
                
                // Set restoration flag to prevent welcome message
                localStorage.setItem("isRestoringChat", "true");
                
                // Clear existing chat messages
          const chatMessages = document.getElementById("chat-messages");
          chatMessages.innerHTML = "";
                
                // Restore chat history
                if (blog.chatHistory && blog.chatHistory.length > 0) {
                    await window.restoreChatMessages(blog.chatHistory);
                    
                    // Set conversation state based on chat history
                    isFirstPrompt = false;
                    conversationStarted = true;
                    
                    // Update global state
                    window.isFirstPrompt = isFirstPrompt;
                    window.conversationStarted = conversationStarted;
                } else {
                    // No chat history, treat as new conversation but keep content
                    isFirstPrompt = false;
                    conversationStarted = true;
                    
                    // Update global state
                    window.isFirstPrompt = isFirstPrompt;
                    window.conversationStarted = conversationStarted;
                    
                    // Don't add welcome message when restoring - user can start conversation naturally
                }
                
                // Close the history modal
          const historyModal = document.getElementById("historyModal");
                if (historyModal) {
            historyModal.style.display = "none";
                }
          const historyModalOverlay = document.getElementById(
            "historyModalOverlay"
          );
                if (historyModalOverlay) {
            historyModalOverlay.style.display = "none";
                }
                
                // Clear restoration flag after successful restoration
                localStorage.removeItem("isRestoringChat");
                
                // Show success toast
          const showToast = window.showToast || function (msg, type) {};
          showToast("Blog and chat history loaded successfully", "success");
            } catch (error) {
          console.error("=== Error loading blog with chat history ===");
          console.error("Error details:", error);
          console.error("Blog ID that failed:", blogId);

          const showToast = window.showToast || function (msg, type) {};
          showToast(
            "Failed to load blog with chat history: " + error.message,
            "error"
          );
                
                // Clear restoration flag on error
                localStorage.removeItem("isRestoringChat");
                
                // Try fallback to regular blog loading
                
                try {
                    await restoreBlog(blogId);
                } catch (fallbackError) {
            console.error("Fallback also failed:", fallbackError);
                    // Close modal
            const historyModal = document.getElementById("historyModal");
                    if (historyModal) {
              historyModal.style.display = "none";
                    }
            const historyModalOverlay = document.getElementById(
              "historyModalOverlay"
            );
                    if (historyModalOverlay) {
              historyModalOverlay.style.display = "none";
                    }
                }
            }
      };

        // Function to load blog with chat history with loading state
        async function loadBlogWithChatHistoryWithLoading(blogId, button) {
            // Show loading state on button
            const originalContent = button.innerHTML;
            button.innerHTML = `
                <i class="fas fa-spinner fa-spin"></i>
                <span>Restoring...</span>
            `;
            button.disabled = true;

            try {
                await window.loadBlogWithChatHistory(blogId);
            } catch (error) {
                console.error("Error loading blog with chat history:", error);
            } finally {
                // Restore original button state
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        }

        // Function to restore chat messages in the chat interface
      window.restoreChatMessages = async function restoreChatMessages(
        chatHistory
      ) {
        const chatMessages = document.getElementById("chat-messages");
            
            if (!chatMessages) {
          console.error("Chat messages container not found");
                return;
            }
            
            // Filter out system messages and empty messages
        const validMessages = chatHistory.filter((message) => {
                const content = message.content?.trim();
                if (!content) return false;
                
                // Skip system messages with emoji indicators
          const systemEmojis = [
            "üíæ",
            "üîç",
            "‚úÖ",
            "üîÑ",
            "üìÑ",
            "üìä",
            "üé®",
            "‚ú®",
            "‚ö†Ô∏è",
          ];
          return !systemEmojis.some((emoji) => content.includes(emoji));
        });
            
            for (const message of validMessages) {
          const messageElement = document.createElement("div");
          messageElement.className = "message-wrapper";
                
                // Use the exact same structure as addMessageToChat
          const isUser = message.type === "user";
                
                // Check if message has images - handle MongoDB Map objects properly
                
                let imageUrls = null;
                if (message.metadata) {
                    // Handle different metadata formats from MongoDB
                    if (message.metadata.imageUrls) {
                        imageUrls = message.metadata.imageUrls;
            } else if (
              message.metadata._doc &&
              message.metadata._doc.imageUrls
            ) {
                        // Handle Mongoose document wrapper
                        imageUrls = message.metadata._doc.imageUrls;
            } else if (typeof message.metadata === "object") {
                        // Check if metadata itself contains the URLs
                        const metadataValues = Object.values(message.metadata);
                        for (const value of metadataValues) {
                if (
                  Array.isArray(value) &&
                  value.length > 0 &&
                  typeof value[0] === "string" &&
                  value[0].includes("http")
                ) {
                                imageUrls = value;
                                break;
                            }
                        }
                    }
                }
                
                // Convert different formats to array
                if (imageUrls) {
            if (typeof imageUrls === "string") {
                        imageUrls = [imageUrls];
            } else if (
              typeof imageUrls === "object" &&
              !Array.isArray(imageUrls)
            ) {
                        imageUrls = Object.values(imageUrls);
                    }
                }
                
          const hasImages =
            imageUrls && Array.isArray(imageUrls) && imageUrls.length > 0;
                
                let messageContent;
                if (hasImages) {
            const imageElements = imageUrls
              .map(
                (url) =>
                        `<img src="${url}" alt="Generated image" style="max-width: 200px; margin: 5px;">`
              )
              .join("");
                    
                    messageContent = `
                        <div class="${isUser ? "user-avatar" : "ai-avatar"}">${
              isUser ? "You" : "AI"
            }</div>
                        <div class="message-meta">
                            <div class="message ${
                              isUser ? "user-message" : "ai-message"
                            }">
                                <div class="message-content">
                                    <p>${message.content}</p>
                                    <div class="generated-images">${imageElements}</div>
                                </div>
                                <div class="message-time">${formatMessageTime(
                                  message.timestamp
                                )}</div>
                            </div>
                        </div>
                    `;
                } else {
                    messageContent = `
                        <div class="${isUser ? "user-avatar" : "ai-avatar"}">${
              isUser ? "You" : "AI"
            }</div>
                        <div class="message-meta">
                            <div class="message ${
                              isUser ? "user-message" : "ai-message"
                            }">
                                <div class="message-content">
                                    <p>${message.content}</p>
                                </div>
                                <div class="message-time">${formatMessageTime(
                                  message.timestamp
                                )}</div>
                            </div>
                        </div>
                    `;
                }
                
                messageElement.innerHTML = messageContent;
                
                // Add restore button for modification messages (AI responses that mention modifications)
                if (!isUser && isModificationMessage(message.content)) {
                    const messageMeta = messageElement.querySelector('.message-meta');
                    if (messageMeta) {
                        const restoreButton = document.createElement('button');
                        restoreButton.className = 'restore-button';
                        restoreButton.innerHTML = '<i class="fas fa-undo"></i>';
                        restoreButton.title = 'Restore previous version';
                        restoreButton.onclick = () => {
                            // For historical messages, we'll need to get the previous content from localStorage
                            const previousContent = localStorage.getItem('previousBlogContent');
                            if (previousContent) {
                                restoreBlogContent(previousContent);
                            } else {
                                addMessageToChat("Sorry, the previous version is not available for this message.", false);
                            }
                        };
                        messageMeta.appendChild(restoreButton);
                    }
                }
                
                chatMessages.appendChild(messageElement);
            }
            
            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;
      };

        // Function to format message time
        function formatMessageTime(timestamp) {
            const date = new Date(timestamp);
        return date.toLocaleString("en-US", {
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
            });
        }

        // Function to extract chat messages from the chat interface
        function extractChatMessages() {
        const chatMessagesContainer = document.getElementById("chat-messages");
            const messages = [];
            
        Array.from(chatMessagesContainer.children).forEach(
          (messageWrapper, index) => {
            try {
                    // Find user or AI avatar to determine message type
              const userAvatar = messageWrapper.querySelector(".user-avatar");
              const aiAvatar = messageWrapper.querySelector(".ai-avatar");
                    
                    // Find message content
              const messageContent =
                messageWrapper.querySelector(".message-content p");
                    
                    if (messageContent && messageContent.textContent.trim()) {
                const messageType = userAvatar ? "user" : "ai";
                        const content = messageContent.textContent.trim();
                        
                        // Skip system messages with emoji indicators
                const systemEmojis = [
                  "üíæ",
                  "üîç",
                  "‚úÖ",
                  "üîÑ",
                  "üìÑ",
                  "üìä",
                  "üé®",
                  "‚ú®",
                  "‚ö†Ô∏è",
                ];
                if (!systemEmojis.some((emoji) => content.includes(emoji))) {
                            // Check for images in this message
                  const generatedImages =
                    messageWrapper.querySelector(".generated-images");
                            let metadata = {};
                            
                            if (generatedImages) {
                    const imageElements =
                      generatedImages.querySelectorAll("img");
                                if (imageElements.length > 0) {
                      metadata.imageUrls = Array.from(imageElements).map(
                        (img) => img.src
                      );
                                }
                            }
                            
                            const messageData = {
                                content: content,
                                type: messageType,
                    timestamp: new Date(),
                            };
                            
                            // Add metadata if images were found
                            if (metadata.imageUrls && metadata.imageUrls.length > 0) {
                                messageData.metadata = metadata;
                            }
                            
                            messages.push(messageData);
                        } else {
                        }
                    } else {
                    }
                } catch (error) {
              console.warn("Error extracting message:", error);
                }
          }
        );
            
            return messages;
        }

        // Function to save chat message with blog association
        async function saveChatMessage(content, senderType, metadata = {}) {
            try {
          const token = localStorage.getItem("token");
                
                // Check if we have a valid token first
                if (!token) {
                    console.log('No auth token found, skipping chat message save');
                    return;
                }
                
                // Save to chat messages collection
                const response = await fetch(`${API_URL}/chat/messages`, {
            method: "POST",
                    headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify({
                        content,
                        senderType,
              metadata,
            }),
                });

                const responseText = await response.text();

                if (!response.ok) {
            console.error("Error saving chat message:", responseText);
                    throw new Error(responseText);
                }

                // Also save to blog's chat history if a blog is active
          const currentBlogId = localStorage.getItem("currentBlogId");
                if (currentBlogId) {
                    try {
                        await fetch(`${API_URL}/blogs/${currentBlogId}/chat`, {
                method: "PATCH",
                            headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${token}`,
                            },
                            body: JSON.stringify({
                                content,
                                type: senderType === 'bot' ? 'ai' : senderType,
                  metadata,
                }),
                        });
                    } catch (blogChatError) {
              console.warn(
                "Failed to save to blog chat history:",
                blogChatError
              );
                        // Don't throw - the main chat message was saved successfully
                    }
                }

                return JSON.parse(responseText);
            } catch (error) {
                // Handle different types of errors
                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    console.warn("Backend server not available, chat message not saved:", error.message);
                    // Don't throw error - allow chat to continue working
                    return null;
                } else {
          console.error("Error saving chat message:", error);
                    // For other errors, still don't throw to avoid breaking chat
                    return null;
                }
            }
        }

        // Function to manually save current chat history to the current blog
        async function saveChatHistoryToBlog() {
        const currentBlogId = localStorage.getItem("currentBlogId");
            if (!currentBlogId) {
                return;
            }

            try {
          const token = localStorage.getItem("token");
                const chatMessages = extractChatMessages();

                const response = await fetch(`${API_URL}/blogs/${currentBlogId}`, {
            method: "PATCH",
                    headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
                    },
                    body: JSON.stringify({
              chatHistory: chatMessages,
            }),
                });

                if (!response.ok) {
            throw new Error("Failed to save chat history to blog");
                }
            } catch (error) {
          console.error("Error saving chat history to blog:", error);
            }
        }

        // Function to automatically save blog to MongoDB
        async function autoSaveBlogToMongoDB(content, originalPrompt) {
            try {
          const token = localStorage.getItem("token");
                if (!token) {
            addMessageToChat(
              "‚ö†Ô∏è Blog generated but not saved - please log in to save your blogs.",
              false
            );
                    return;
                }

                addMessageToChat("üíæ Automatically saving your blog...", false);

                // Get chat messages with proper structure
                const chatMessages = extractChatMessages();

                // Create temporary div to extract blog data
          const tempDiv = document.createElement("div");
                tempDiv.innerHTML = content;

                // Get the first paragraph for summary
          const firstParagraph = tempDiv.querySelector("p")?.textContent || "";
          const summary =
            firstParagraph.length > 500
              ? firstParagraph.substring(0, 497) + "..."
              : firstParagraph;

                const blogData = {
            title: tempDiv.querySelector("h1")?.textContent || "Untitled Blog",
                    content: content,
            category: originalPrompt.split(" ")[0], // Using first word of prompt as category
                    summary: summary,
            keywords: Array.from(
              analyzeKeywordUsage(tempDiv.textContent).keys()
            ),
            status: "draft",
                    generationPrompt: originalPrompt,
                    isAIGenerated: true,
            chatHistory: chatMessages,
                };

                // Check if we're updating an existing blog
                // Ensure we have the most current blog ID from localStorage
                const blogId = localStorage.getItem("currentBlogId") || window.currentBlogId;
          const url = blogId
            ? `${API_URL}/blogs/${blogId}`
            : `${API_URL}/blogs`;
          const method = blogId ? "PATCH" : "POST";

                const response = await fetch(url, {
                    method: method,
                    headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${token}`,
                    },
            body: JSON.stringify(blogData),
                });

                if (!response.ok) {
            throw new Error("Failed to save blog to database");
                }

                const savedBlog = await response.json();
                
                // Store the blog ID if it's a new blog
                if (!blogId && savedBlog.data?.blog?._id) {
                    currentBlogId = savedBlog.data.blog._id;
                    localStorage.setItem("currentBlogId", currentBlogId);
                    window.currentBlogId = currentBlogId;
                }

                // Update history button with latest blog
          const historyButton = document.querySelector(".history-button");
                if (historyButton) {
            historyButton.setAttribute(
              "data-last-blog",
              savedBlog.data?.blog?._id || ""
            );
            historyButton.setAttribute("data-last-title", blogData.title);
                    historyButton.title = `Last saved: ${blogData.title}`;
                }

          addMessageToChat(
            blogId
              ? "‚úÖ Blog has been automatically updated in your account!"
              : "‚úÖ Blog has been automatically saved to your account!",
            false
          );
                
                // Return the saved blog data
                return savedBlog.data?.blog || savedBlog;
            } catch (error) {
          console.error("Error auto-saving blog:", error);
          addMessageToChat(
            "‚ùå Error auto-saving blog. Please check your connection and login status.",
            false
          );
                return null;
            }
        }

        // ... rest of your existing code ...
        function showHistoryList() {
        document.getElementById("historyList").style.display = "block";
        document.getElementById("historyPreview").style.display = "none";
        }

        // Function to preview a blog with loading state
        async function previewBlogWithLoading(blogId, button) {
            // Show loading state on button
            const originalContent = button.innerHTML;
            button.innerHTML = `
                <i class="fas fa-spinner fa-spin"></i>
                <span>Loading...</span>
            `;
            button.disabled = true;

            try {
                const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!response.ok) {
                    throw new Error("Failed to fetch blog");
                }

                const blog = await response.json();
                
                // Hide list and show preview
                document.getElementById("historyList").style.display = "none";
                const previewDiv = document.getElementById("historyPreview");
                previewDiv.style.display = "block";

                // Display chat history if available
                const chatContainer = previewDiv.querySelector(
                    ".history-chat-messages"
                );
                chatContainer.innerHTML = "<h4>Chat History</h4>";
                if (
                    blog.data.blog.chatHistory &&
                    blog.data.blog.chatHistory.length > 0
                ) {
                    blog.data.blog.chatHistory.forEach((msg) => {
                        const messageDiv = document.createElement("div");
                        messageDiv.className = `message ${msg.type}`;
                        messageDiv.textContent = msg.content;
                        chatContainer.appendChild(messageDiv);
                    });
                } else {
                    chatContainer.innerHTML += "<p>No chat history available</p>";
                }

                // Display blog content
                const blogContainer = previewDiv.querySelector(
                    ".history-blog-content"
                );
                blogContainer.innerHTML =
                    "<h4>Blog Content</h4>" + blog.data.blog.content;
            } catch (error) {
                console.error("Error fetching blog:", error);
                showToast("Error loading blog preview", "error");
            } finally {
                // Restore original button state
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        }

        // Function to preview a blog (original function for backward compatibility)
        async function previewBlog(blogId) {
            try {
                const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!response.ok) {
                    throw new Error("Failed to fetch blog");
                }

                const blog = await response.json();
                
                // Hide list and show preview
                document.getElementById("historyList").style.display = "none";
                const previewDiv = document.getElementById("historyPreview");
                previewDiv.style.display = "block";

                // Display chat history if available
                const chatContainer = previewDiv.querySelector(
                    ".history-chat-messages"
                );
                chatContainer.innerHTML = "<h4>Chat History</h4>";
                if (
                    blog.data.blog.chatHistory &&
                    blog.data.blog.chatHistory.length > 0
                ) {
                    blog.data.blog.chatHistory.forEach((msg) => {
                        const messageDiv = document.createElement("div");
                        messageDiv.className = `message ${msg.type}`;
                        messageDiv.textContent = msg.content;
                        chatContainer.appendChild(messageDiv);
                    });
                } else {
                    chatContainer.innerHTML += "<p>No chat history available</p>";
                }

                // Display blog content
                const blogContainer = previewDiv.querySelector(
                    ".history-blog-content"
                );
                blogContainer.innerHTML =
                    "<h4>Blog Content</h4>" + blog.data.blog.content;
            } catch (error) {
                console.error("Error fetching blog:", error);
                showToast("Error loading blog preview", "error");
            }
        }

        // Function to restore a blog
        async function restoreBlog(blogId) {
            try {
          const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                    headers: {
              Authorization: `Bearer ${token}`,
            },
                });

                if (!response.ok) {
            throw new Error("Failed to fetch blog");
                }

                const blog = await response.json();

                // Store the blog ID for future updates
                currentBlogId = blogId;
                localStorage.setItem("currentBlogId", blogId);
                window.currentBlogId = currentBlogId;

                // Restore blog content to editor
                quill.root.innerHTML = blog.data.blog.content;
                localStorage.setItem("BlogGenerated", blog.data.blog.content);

                // Close the history modal
          const historyModal = document.getElementById("historyModal");
                if (historyModal) {
            historyModal.style.display = "none";
                }
          const historyModalOverlay = document.getElementById(
            "historyModalOverlay"
          );
                if (historyModalOverlay) {
            historyModalOverlay.style.display = "none";
                }

                // Show success message
          addMessageToChat(
            "‚úÖ Blog has been restored and is ready for editing!",
            false
          );
            } catch (error) {
          console.error("Error restoring blog:", error);
                addMessageToChat("‚ùå Error restoring blog", false);
            }
        }

        // Function to format relative time
        function getRelativeTime(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffInSeconds = Math.floor((now - date) / 1000);
            
        if (diffInSeconds < 60) return "just now";
        if (diffInSeconds < 3600)
          return `${Math.floor(diffInSeconds / 60)} minutes ago`;
        if (diffInSeconds < 86400)
          return `${Math.floor(diffInSeconds / 3600)} hours ago`;
        if (diffInSeconds < 604800)
          return `${Math.floor(diffInSeconds / 86400)} days ago`;
            return date.toLocaleDateString();
        }

        // Function to show history modal
        async function showHistoryModal() {
        const modal = document.getElementById("historyModal");
        const historyList = document.getElementById("historyList");
            historyList.innerHTML = `
                <div class="loading">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>Loading your blog history...</p>
                </div>
            `;
            
            try {
          const token = localStorage.getItem("token");
                if (!token) {
            throw new Error("No authentication token found. Please log in.");
                }

                // Add timestamp to URL to prevent caching
                const timestamp = new Date().getTime();
                const response = await fetch(`${API_URL}/blogs/user?_=${timestamp}`, {
                    headers: {
              Authorization: `Bearer ${token}`,
            },
                });

                if (!response.ok) {
                    const errorText = await response.text();
            console.error("API Error:", response.status, errorText);
                    throw new Error(`Failed to fetch blog history: ${response.status}`);
                }

                const data = await response.json();
                 // For debugging

                // Ensure we have an array of blogs
          const blogs = Array.isArray(data) ? data : data.blogs || [];
                 // For debugging
                
                if (!Array.isArray(blogs)) {
            throw new Error("Invalid blog data received from server");
                }
                
                if (blogs.length === 0) {
                    historyList.innerHTML = `
                        <div class="no-history">
                            <i class="fas fa-history"></i>
                            <p>No saved blogs found</p>
                            <small>Your saved blogs will appear here</small>
                        </div>
                    `;
                } else {
                    historyList.innerHTML = `
                        <div class="history-header">
                            <div class="history-title-section">
                            <h4>Your Saved Blogs</h4>
                            <small>${blogs.length} blog${
              blogs.length !== 1 ? "s" : ""
            } found</small>
                            </div>
                            <div class="history-actions">
                                <button class="select-all-btn" id="selectAllBtn" onclick="toggleSelectAll()">
                                    <i class="fas fa-check-square"></i> Select All
                                </button>
                                <button class="clear-selected-btn" id="clearSelectedBtn" onclick="clearSelectedBlogs()" disabled>
                                    <i class="fas fa-trash-alt"></i> Clear Selected
                                </button>
                            </div>
                        </div>
                    `;
            blogs
              .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
              .forEach((blog) => {
                const blogItem = document.createElement("div");
                blogItem.className = "history-item";
                        
                        // Format date and time
                        const date = new Date(blog.createdAt);
                        const formattedDate = date.toLocaleDateString();
                        const formattedTime = date.toLocaleTimeString();
                        
                        blogItem.innerHTML = `
                            <div class="history-item-card">
                                <div class="history-item-main">
                                    <div class="history-item-checkbox">
                                        <input type="checkbox" class="blog-checkbox" data-blog-id="${blog._id}" onchange="updateClearButton()">
                                    </div>
                                    <div class="history-item-content">
                                <div class="history-item-title">
                                    <h4>${blog.title}</h4>
                                        </div>
                                        <div class="history-item-meta">
                                        <span class="history-date">
                                            <i class="far fa-calendar-alt"></i> ${formattedDate}
                                        </span>
                                        <span class="history-time">
                                            <i class="far fa-clock"></i> ${formattedTime}
                                        </span>
                                        </div>
                                    </div>
                                </div>
                                <div class="history-item-actions">
                                    <button onclick="previewBlogWithLoading('${blog._id}', this)" class="action-btn preview-btn" title="Preview Blog" data-blog-id="${blog._id}">
                                        <i class="fas fa-eye"></i>
                                        <span>Preview</span>
                                    </button>
                                    <button onclick="loadBlogWithChatHistoryWithLoading('${blog._id}', this)" class="action-btn restore-btn" title="Restore Blog with Chat History" data-blog-id="${blog._id}">
                                        <i class="fas fa-sync-alt"></i>
                                        <span>Restore</span>
                                </button>
                                    <button onclick="deleteBlogWithLoading('${blog._id}', this)" class="action-btn delete-btn" title="Delete Blog" data-blog-id="${blog._id}">
                                        <i class="fas fa-trash-alt"></i>
                                        <span>Delete</span>
                                </button>
                                </div>
                            </div>
                        `;
                        historyList.appendChild(blogItem);
                    });
                }
            } catch (error) {
          console.error("Error loading blog history:", error);
          let errorMessage = "Error loading blog history";

          if (error.message.includes("No authentication token found")) {
            errorMessage = "Please log in to view your blog history";
          } else if (error.message.includes("401")) {
            errorMessage = "Your session has expired. Please log in again";
          } else if (error.message.includes("Invalid blog data")) {
            errorMessage = "Unable to load blogs. Please try again later";
                }
                
                historyList.innerHTML = `
                    <div class="error">
                        <i class="fas fa-exclamation-circle"></i>
                        <p>${errorMessage}</p>
                        ${
                          error.message.includes("log in")
                            ? '<button onclick="window.location.href=\'login.html\'" class="login-btn">Log In</button>'
                            : ""
                        }
                    </div>
                `;
            }
            
            // Show the modal
        modal.style.display = "block";
        document.getElementById("historyModalOverlay").style.display = "block";
            
            // Show list view by default
            showHistoryList();
        }

        // Function to close history modal
        function closeHistoryModal() {
        document.getElementById("historyModal").style.display = "none";
        document.getElementById("historyModalOverlay").style.display = "none";
        }

        // Initialize event listeners when the page loads
      document.addEventListener("DOMContentLoaded", function () {
            // Initialize history button
        const historyButton = document.getElementById("history-button");
        const closeHistoryModalBtn =
          document.getElementById("closeHistoryModal");
        const historyModalOverlay = document.getElementById(
          "historyModalOverlay"
        );

            if (historyButton) {
                // Remove any existing listeners
                historyButton.replaceWith(historyButton.cloneNode(true));
          const newHistoryButton = document.getElementById("history-button");
                
                // Add the history modal click handler
          newHistoryButton.addEventListener("click", async function (e) {
                    e.preventDefault();
                    
                    // Show loading state on button
                    const originalContent = newHistoryButton.innerHTML;
                    newHistoryButton.innerHTML = `
                        <i class="fa-solid fa-spinner fa-spin"></i>
                        <span>Loading...</span>
                    `;
                    newHistoryButton.disabled = true;
                    
                    try {
                        await showHistoryModal();
                    } catch (error) {
                        console.error("Error showing history modal:", error);
                    } finally {
                        // Restore original button state
                        newHistoryButton.innerHTML = originalContent;
                        newHistoryButton.disabled = false;
                    }
                });
            }

            if (closeHistoryModalBtn) {
          closeHistoryModalBtn.addEventListener("click", closeHistoryModal);
            }

            if (historyModalOverlay) {
          historyModalOverlay.addEventListener("click", closeHistoryModal);
            }
        });

        // Function to delete a blog with loading state
        async function deleteBlogWithLoading(blogId, button) {
            if (
                !confirm(
                    "Are you sure you want to delete this blog? This action cannot be undone."
                )
            ) {
                return;
            }

            // Show loading state on button
            const originalContent = button.innerHTML;
            button.innerHTML = `
                <i class="fas fa-spinner fa-spin"></i>
                <span>Deleting...</span>
            `;
            button.disabled = true;

            try {
                const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                    method: "DELETE",
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!response.ok) {
                    throw new Error("Failed to delete blog");
                }

                // Refresh the history list
                await showHistoryModal();
                
                // Show success message
                addMessageToChat("‚úÖ Blog has been deleted successfully!", false);
            } catch (error) {
                console.error("Error deleting blog:", error);
                showToast("Error deleting blog. Please try again.", "error");
            } finally {
                // Restore original button state
                button.innerHTML = originalContent;
                button.disabled = false;
            }
        }

        // Function to delete a blog (original function for backward compatibility)
        async function deleteBlog(blogId) {
            // Show confirmation toast instead of alert
            const showToast = window.showToast || function (msg, type) {};
            showToast("Are you sure you want to delete this blog? This action cannot be undone.", "warning");
            
            // For now, we'll proceed with deletion since we can't easily implement a confirmation dialog with toast
            // In a real implementation, you might want to use a custom modal for confirmation
            
            try {
                const token = localStorage.getItem("token");
                const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                    method: "DELETE",
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });

                if (!response.ok) {
                    throw new Error("Failed to delete blog");
                }

                // Refresh the history list
                await showHistoryModal();
                
                // Show success message
                showToast("‚úÖ Blog has been deleted successfully!", "success");
            } catch (error) {
                console.error("Error deleting blog:", error);
                showToast("Error deleting blog. Please try again.", "error");
            }
        }

        // Function to toggle select all checkboxes
        function toggleSelectAll() {
        const selectAllBtn = document.getElementById("selectAllBtn");
        const checkboxes = document.querySelectorAll(".blog-checkbox");
        const allChecked = Array.from(checkboxes).every((cb) => cb.checked);

        checkboxes.forEach((checkbox) => {
                checkbox.checked = !allChecked;
            });
            
            // Update button text and icon
            if (allChecked) {
          selectAllBtn.innerHTML =
            '<i class="fas fa-check-square"></i> Select All';
            } else {
          selectAllBtn.innerHTML =
            '<i class="fas fa-minus-square"></i> Deselect All';
            }
            
            updateClearButton();
        }

        // Function to update the clear button state
        function updateClearButton() {
        const clearBtn = document.getElementById("clearSelectedBtn");
        const selectAllBtn = document.getElementById("selectAllBtn");
        const checkboxes = document.querySelectorAll(".blog-checkbox");
        const checkedBoxes = document.querySelectorAll(
          ".blog-checkbox:checked"
        );
        const allChecked = Array.from(checkboxes).every((cb) => cb.checked);
            
            // Enable/disable clear button based on selection
            clearBtn.disabled = checkedBoxes.length === 0;
            
            // Update select all button text
            if (allChecked && checkboxes.length > 0) {
          selectAllBtn.innerHTML =
            '<i class="fas fa-minus-square"></i> Deselect All';
            } else {
          selectAllBtn.innerHTML =
            '<i class="fas fa-check-square"></i> Select All';
            }
            
            // Update clear button text to show count
            if (checkedBoxes.length > 0) {
                clearBtn.innerHTML = `<i class="fas fa-trash-alt"></i> Clear Selected (${checkedBoxes.length})`;
            } else {
          clearBtn.innerHTML =
            '<i class="fas fa-trash-alt"></i> Clear Selected';
            }
        }

        // Function to clear selected blogs
        async function clearSelectedBlogs() {
        const checkedBoxes = document.querySelectorAll(
          ".blog-checkbox:checked"
        );
        const selectedIds = Array.from(checkedBoxes).map((cb) =>
          cb.getAttribute("data-blog-id")
        );
            
            if (selectedIds.length === 0) {
                const showToast = window.showToast || function (msg, type) {};
                showToast("Please select blogs to delete.", "warning");
                return;
            }
            
        const confirmMessage = `Are you sure you want to delete ${
          selectedIds.length
        } selected blog${
          selectedIds.length !== 1 ? "s" : ""
        }? This action cannot be undone.`;
            
            // Show confirmation toast instead of alert
            const showToast = window.showToast || function (msg, type) {};
            showToast(confirmMessage, "warning");
            
            // For now, we'll proceed with deletion since we can't easily implement a confirmation dialog with toast
            // In a real implementation, you might want to use a custom modal for confirmation

        const clearBtn = document.getElementById("clearSelectedBtn");
            const originalText = clearBtn.innerHTML;
            clearBtn.disabled = true;
        clearBtn.innerHTML =
          '<i class="fas fa-spinner fa-spin"></i> Deleting...';

            try {
          const token = localStorage.getItem("token");
                let deletedCount = 0;
                let failedCount = 0;

                // Delete each selected blog
                for (const blogId of selectedIds) {
                    try {
                        const response = await fetch(`${API_URL}/blogs/${blogId}`, {
                method: "DELETE",
                            headers: {
                  Authorization: `Bearer ${token}`,
                },
                        });

                        if (response.ok) {
                            deletedCount++;
                        } else {
                            failedCount++;
                        }
                    } catch (error) {
                        console.error(`Error deleting blog ${blogId}:`, error);
                        failedCount++;
                    }
                }

                // Refresh the history list
                await showHistoryModal();
                
                // Show success/error message
          let message = "";
                if (deletedCount > 0) {
            message += `‚úÖ Successfully deleted ${deletedCount} blog${
              deletedCount !== 1 ? "s" : ""
            }!`;
                }
                if (failedCount > 0) {
            message += ` ‚ùå Failed to delete ${failedCount} blog${
              failedCount !== 1 ? "s" : ""
            }.`;
                }
                
                const showToast = window.showToast || function (msg, type) {};
                showToast(message, "success");
            } catch (error) {
          console.error("Error clearing selected blogs:", error);
                const showToast = window.showToast || function (msg, type) {};
                showToast("Error deleting selected blogs. Please try again.", "error");
                
                // Reset button
                clearBtn.disabled = false;
                clearBtn.innerHTML = originalText;
            }
        }

        // Function to clear current blog
        function clearCurrentBlog() {
            currentBlogId = null;
        quill.root.innerHTML =
          "<h2>Write a blog here or generate a blog using the chat section</h2>";
        }
    </script>

    <!-- History Modal -->
    <div class="history-modal-overlay" id="historyModalOverlay"></div>
    <div class="history-modal" id="historyModal">
        <div class="history-modal-header">
            <h3 class="history-modal-title">Blog History</h3>
            <button class="close-history-modal" id="closeHistoryModal">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="history-list" id="historyList">
            <!-- History items will be added here dynamically -->
        </div>
      <div class="history-preview" id="historyPreview" style="display: none">
            <button class="back-to-list" onclick="showHistoryList()">
                <i class="fas fa-arrow-left"></i> Back to List
            </button>
            <div class="history-chat-messages"></div>
            <div class="history-blog-content"></div>
        </div>
    </div>

    <style>
        /* History Modal Selection Styles */
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
            padding: 15px 0;
            border-bottom: 2px solid #f0f0f0;
            gap: 15px;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            box-sizing: border-box;
        }

        .history-title-section h4 {
            margin: 0 0 5px 0;
            font-size: 1.2rem;
            color: #2d3436;
        }

        .history-title-section small {
            color: #636e72;
            font-size: 0.9rem;
        }

        .history-actions {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

      .select-all-btn,
      .clear-selected-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .select-all-btn {
            background: #6c5ce7;
            color: white;
        }

        .select-all-btn:hover {
            background: #5f4dd0;
            transform: translateY(-1px);
        }

        .clear-selected-btn {
            background: #e74c3c;
            color: white;
        }

        .clear-selected-btn:hover:not(:disabled) {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .clear-selected-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .history-item {
            margin-bottom: 16px;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .history-item-card {
            background: #ffffff;
            border: 1px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 100%;
            box-sizing: border-box;
        }

        .history-item-card:hover {
            border-color: #6c5ce7;
            box-shadow: 0 4px 12px rgba(108, 92, 231, 0.15);
            transform: translateY(-2px);
        }

        .history-item-main {
            display: flex;
            align-items: flex-start;
            gap: 15px;
            margin-bottom: 20px;
        }

        .history-item-checkbox {
            display: flex;
            align-items: center;
            padding-top: 4px;
        }

        .blog-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #6c5ce7;
            border-radius: 4px;
        }

        .history-item-content {
            flex: 1;
            min-width: 0;
        }

        .history-item-title h4 {
            margin: 0 0 8px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #2d3436;
            line-height: 1.4;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 100%;
        }

        .history-item-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

      .history-date,
      .history-time {
            display: flex;
            align-items: center;
            gap: 6px;
            color: #636e72;
            font-size: 0.85rem;
        }

      .history-date i,
      .history-time i {
            color: #6c5ce7;
            font-size: 0.9rem;
        }

        .history-item-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 90px;
            justify-content: center;
        }

        .preview-btn {
            background: #74b9ff;
            color: white;
        }

        .preview-btn:hover {
            background: #0984e3;
            transform: translateY(-1px);
        }

        .restore-btn {
            background: #00b894;
            color: white;
        }

        .restore-btn:hover {
            background: #00a085;
            transform: translateY(-1px);
        }

        .delete-btn {
            background: #e74c3c;
            color: white;
        }

        .delete-btn:hover {
            background: #c0392b;
            transform: translateY(-1px);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        .action-btn i {
            font-size: 0.9rem;
        }

        /* Mobile responsive adjustments */
        @media (max-width: 768px) {
            .history-header {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }

            .history-actions {
                justify-content: stretch;
            }

        .select-all-btn,
        .clear-selected-btn {
                flex: 1;
                justify-content: center;
                font-size: 0.8rem;
                padding: 6px 12px;
            }

            .history-item-card {
                padding: 16px;
            }

            .history-item {
                max-width: 500px;
            }

            .history-list {
                padding: 0 15px;
            }

            .history-item-main {
                gap: 12px;
                margin-bottom: 16px;
            }

            .blog-checkbox {
                width: 18px;
                height: 18px;
            }

            .history-item-title h4 {
                font-size: 1rem;
            }

            .history-item-meta {
                gap: 15px;
            }

        .history-date,
        .history-time {
                font-size: 0.8rem;
            }

            .history-item-actions {
                gap: 8px;
            }

            .action-btn {
                padding: 6px 12px;
                font-size: 0.8rem;
                min-width: 80px;
            }
        }

        @media (max-width: 480px) {
            .history-actions {
                flex-direction: column;
                gap: 8px;
            }

        .select-all-btn,
        .clear-selected-btn {
                font-size: 0.75rem;
                padding: 5px 10px;
            }

            .history-item-card {
                padding: 12px;
            }

            .history-item {
                max-width: 95vw;
            }

            .history-list {
                padding: 0 10px;
            }

            .history-item-main {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 12px;
            }

            .history-item-checkbox {
                padding-top: 0;
                order: -1;
            }

            .blog-checkbox {
                width: 16px;
                height: 16px;
            }

            .history-item-title h4 {
                font-size: 0.95rem;
                margin-bottom: 6px;
            }

            .history-item-meta {
                flex-direction: column;
                gap: 8px;
            }

        .history-date,
        .history-time {
                font-size: 0.75rem;
            }

            .history-item-actions {
                flex-direction: column;
                gap: 6px;
            }

            .action-btn {
                padding: 8px 12px;
                font-size: 0.8rem;
                min-width: unset;
                width: 100%;
            }

            .action-btn span {
                display: inline;
            }
        }
    </style>

    <!-- Chat History Modal -->
    <div id="chatHistoryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Chat History</h3>
                <button id="closeChatHistoryModal" class="close-button">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="chatHistoryContainer" class="chat-history-container">
                <!-- Chat history will be loaded here -->
            </div>
        </div>
    </div>

    <!-- History Dropdown -->
    <div id="history-dropdown" class="history-dropdown">
        <div class="history-dropdown-header">
            <h3>Blog History</h3>
            <button id="close-history-dropdown" class="close-button">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div id="history-dropdown-content" class="history-dropdown-content">
            <!-- Blog history will be loaded here -->
        </div>
    </div>
</body>
</html>
